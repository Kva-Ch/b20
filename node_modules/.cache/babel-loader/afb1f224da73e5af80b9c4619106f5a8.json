{"ast":null,"code":"import { useGlobalListeners as $fA3fN$useGlobalListeners, clamp as $fA3fN$clamp, mergeProps as $fA3fN$mergeProps, focusWithoutScrolling as $fA3fN$focusWithoutScrolling } from \"@react-aria/utils\";\nimport { useRef as $fA3fN$useRef, useCallback as $fA3fN$useCallback, useEffect as $fA3fN$useEffect } from \"react\";\nimport { useMove as $fA3fN$useMove, setInteractionModality as $fA3fN$setInteractionModality, useKeyboard as $fA3fN$useKeyboard } from \"@react-aria/interactions\";\nimport { useLabel as $fA3fN$useLabel } from \"@react-aria/label\";\nimport { useLocale as $fA3fN$useLocale } from \"@react-aria/i18n\";\nimport { useFocusable as $fA3fN$useFocusable } from \"@react-aria/focus\";\nconst $aa519ee6cf463259$export$7a8d2b02c9371cbf = new WeakMap();\n\nfunction $aa519ee6cf463259$export$68e648cbec363a18(state, index) {\n  let id = $aa519ee6cf463259$export$7a8d2b02c9371cbf.get(state);\n  if (!id) throw new Error('Unknown slider state');\n  return `${id}-${index}`;\n}\n\nfunction $bcca50147b47f54d$export$56b2c08e277f365(props, state, trackRef) {\n  let {\n    labelProps: labelProps,\n    fieldProps: fieldProps\n  } = $fA3fN$useLabel(props);\n  let isVertical = props.orientation === 'vertical';\n\n  var _id; // Attach id of the label to the state so it can be accessed by useSliderThumb.\n\n\n  $aa519ee6cf463259$export$7a8d2b02c9371cbf.set(state, (_id = labelProps.id) !== null && _id !== void 0 ? _id : fieldProps.id);\n  let {\n    direction: direction\n  } = $fA3fN$useLocale();\n  let {\n    addGlobalListener: addGlobalListener,\n    removeGlobalListener: removeGlobalListener\n  } = $fA3fN$useGlobalListeners(); // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n\n  const realTimeTrackDraggingIndex = $fA3fN$useRef(null);\n  const stateRef = $fA3fN$useRef(null);\n  stateRef.current = state;\n  const reverseX = direction === 'rtl';\n  const currentPosition = $fA3fN$useRef(null);\n  const {\n    moveProps: moveProps\n  } = $fA3fN$useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n\n    onMove(_ref) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY\n      } = _ref;\n      let {\n        height: height,\n        width: width\n      } = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      if (currentPosition.current == null) currentPosition.current = stateRef.current.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) delta = -delta;\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = $fA3fN$clamp(currentPosition.current / size, 0, 1);\n        stateRef.current.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        stateRef.current.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n\n  });\n  let currentPointer = $fA3fN$useRef(undefined);\n\n  let onDownTrack = (e, id, clientX, clientY) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let {\n        height: height,\n        width: width,\n        top: top,\n        left: left\n      } = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width; // Find the closest thumb\n\n      const trackPosition = isVertical ? top : left;\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) percent = 1 - percent;\n      let value = state.getPercentValue(percent); // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) closestThumb = split;else if (split === -1) closestThumb = state.values.length - 1;else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split]; // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) closestThumb = split - 1;else closestThumb = split;\n      } // Confirm that the found closest thumb is editable, not disabled, and move it\n\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else realTimeTrackDraggingIndex.current = null;\n    }\n  };\n\n  let onUpTrack = e => {\n    var ref;\n\n    var _pointerId;\n\n    let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;\n\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if ('htmlFor' in labelProps && labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n\n    labelProps.onClick = () => {\n      var // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      ref;\n      (ref = document.getElementById($aa519ee6cf463259$export$68e648cbec363a18(state, 0))) === null || ref === void 0 ? void 0 : ref.focus();\n      $fA3fN$setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps: labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: 'group',\n      ...fieldProps\n    },\n    trackProps: $fA3fN$mergeProps({\n      onMouseDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n\n      onPointerDown(e) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n\n      onTouchStart(e) {\n        onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n      },\n\n      style: {\n        position: 'relative',\n        touchAction: 'none'\n      }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => $aa519ee6cf463259$export$68e648cbec363a18(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n\nfunction $47b897dc8cdb026b$export$8d15029008292ae(opts, state) {\n  let {\n    index: index,\n    isRequired: isRequired,\n    validationState: validationState,\n    trackRef: trackRef,\n    inputRef: inputRef,\n    orientation = state.orientation\n  } = opts;\n  let isDisabled = opts.isDisabled || state.isDisabled;\n  let isVertical = orientation === 'vertical';\n  let {\n    direction: direction\n  } = $fA3fN$useLocale();\n  let {\n    addGlobalListener: addGlobalListener,\n    removeGlobalListener: removeGlobalListener\n  } = $fA3fN$useGlobalListeners();\n  let labelId = $aa519ee6cf463259$export$7a8d2b02c9371cbf.get(state);\n  var ref1;\n  const {\n    labelProps: labelProps,\n    fieldProps: fieldProps\n  } = $fA3fN$useLabel({ ...opts,\n    id: $aa519ee6cf463259$export$68e648cbec363a18(state, index),\n    'aria-labelledby': `${labelId} ${(ref1 = opts['aria-labelledby']) !== null && ref1 !== void 0 ? ref1 : ''}`.trim()\n  });\n  const value = state.values[index];\n  const focusInput = $fA3fN$useCallback(() => {\n    if (inputRef.current) $fA3fN$focusWithoutScrolling(inputRef.current);\n  }, [inputRef]);\n  const isFocused = state.focusedThumb === index;\n  $fA3fN$useEffect(() => {\n    if (isFocused) focusInput();\n  }, [isFocused, focusInput]);\n  const stateRef = $fA3fN$useRef(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = $fA3fN$useRef(null);\n  let {\n    keyboardProps: keyboardProps\n  } = $fA3fN$useKeyboard({\n    onKeyDown(e) {\n      let {\n        getThumbMaxValue: getThumbMaxValue,\n        getThumbMinValue: getThumbMinValue,\n        decrementThumb: decrementThumb,\n        incrementThumb: incrementThumb,\n        setThumbValue: setThumbValue,\n        setThumbDragging: setThumbDragging,\n        pageSize: pageSize\n      } = stateRef.current; // these are the cases that useMove or useSlider don't handle\n\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      } // same handling as useMove, stopPropagation to prevent useSlider from handling the event as well.\n\n\n      e.preventDefault(); // remember to set this so that onChangeEnd is fired\n\n      setThumbDragging(index, true);\n\n      switch (e.key) {\n        case 'PageUp':\n          incrementThumb(index, pageSize);\n          break;\n\n        case 'PageDown':\n          decrementThumb(index, pageSize);\n          break;\n\n        case 'Home':\n          setThumbValue(index, getThumbMinValue(index));\n          break;\n\n        case 'End':\n          setThumbValue(index, getThumbMaxValue(index));\n          break;\n      }\n\n      setThumbDragging(index, false);\n    }\n\n  });\n  let {\n    moveProps: moveProps\n  } = $fA3fN$useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      stateRef.current.setThumbDragging(index, true);\n    },\n\n    onMove(_ref2) {\n      let {\n        deltaX: deltaX,\n        deltaY: deltaY,\n        pointerType: pointerType,\n        shiftKey: shiftKey\n      } = _ref2;\n      const {\n        getThumbPercent: getThumbPercent,\n        setThumbPercent: setThumbPercent,\n        decrementThumb: decrementThumb,\n        incrementThumb: incrementThumb,\n        step: step,\n        pageSize: pageSize\n      } = stateRef.current;\n      let {\n        width: width,\n        height: height\n      } = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      if (currentPosition.current == null) currentPosition.current = getThumbPercent(index) * size;\n\n      if (pointerType === 'keyboard') {\n        if (deltaX > 0 && reverseX || deltaX < 0 && !reverseX || deltaY > 0) decrementThumb(index, shiftKey ? pageSize : step);else incrementThumb(index, shiftKey ? pageSize : step);\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) delta = -delta;\n        currentPosition.current += delta;\n        setThumbPercent(index, $fA3fN$clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n\n    onMoveEnd() {\n      stateRef.current.setThumbDragging(index, false);\n    }\n\n  }); // Immediately register editability with the state\n\n  state.setThumbEditable(index, !isDisabled);\n  const {\n    focusableProps: focusableProps\n  } = $fA3fN$useFocusable($fA3fN$mergeProps(opts, {\n    onFocus: () => state.setFocusedThumb(index),\n    onBlur: () => state.setFocusedThumb(undefined)\n  }), inputRef);\n  let currentPointer = $fA3fN$useRef(undefined);\n\n  let onDown = id => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  let onUp = e => {\n    var ref;\n\n    var _pointerId;\n\n    let id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;\n\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  let thumbPosition = state.getThumbPercent(index);\n  if (isVertical || direction === 'rtl') thumbPosition = 1 - thumbPosition;\n  let interactions = !isDisabled ? $fA3fN$mergeProps(keyboardProps, moveProps, {\n    onMouseDown: e => {\n      if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n      onDown();\n    },\n    onPointerDown: e => {\n      if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n      onDown(e.pointerId);\n    },\n    onTouchStart: e => {\n      onDown(e.changedTouches[0].identifier);\n    }\n  }) : {}; // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n\n  return {\n    inputProps: $fA3fN$mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      disabled: isDisabled,\n      'aria-orientation': orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      onChange: e => {\n        stateRef.current.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: { ...interactions,\n      style: {\n        position: 'absolute',\n        [isVertical ? 'top' : 'left']: `${thumbPosition * 100}%`,\n        transform: 'translate(-50%, -50%)',\n        touchAction: 'none'\n      }\n    },\n    labelProps: labelProps,\n    isDragging: state.isThumbDragging(index),\n    isDisabled: isDisabled,\n    isFocused: isFocused\n  };\n}\n\nexport { $bcca50147b47f54d$export$56b2c08e277f365 as useSlider, $47b897dc8cdb026b$export$8d15029008292ae as useSliderThumb };","map":{"version":3,"mappings":"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","names":["$aa519ee6cf463259$export$7a8d2b02c9371cbf","WeakMap","$aa519ee6cf463259$export$68e648cbec363a18","state","index","id","get","Error","$bcca50147b47f54d$export$56b2c08e277f365","props","trackRef","labelProps","fieldProps","$fA3fN$useLabel","isVertical","orientation","_id","set","direction","$fA3fN$useLocale","addGlobalListener","removeGlobalListener","$fA3fN$useGlobalListeners","realTimeTrackDraggingIndex","$fA3fN$useRef","stateRef","current","reverseX","currentPosition","moveProps","$fA3fN$useMove","onMoveStart","onMove","deltaX","deltaY","height","width","getBoundingClientRect","size","getThumbPercent","delta","percent","$fA3fN$clamp","setThumbPercent","onMoveEnd","setThumbDragging","currentPointer","undefined","onDownTrack","e","clientX","clientY","isDisabled","values","every","_","i","isThumbDragging","top","left","trackPosition","clickPosition","offset","value","getPercentValue","closestThumb","split","findIndex","v","length","lastLeft","firstRight","Math","abs","isThumbEditable","preventDefault","setFocusedThumb","setThumbValue","window","onUpTrack","ref","_pointerId","pointerId","changedTouches","identifier","htmlFor","onClick","document","getElementById","focus","$fA3fN$setInteractionModality","groupProps","role","trackProps","$fA3fN$mergeProps","onMouseDown","button","altKey","ctrlKey","metaKey","onPointerDown","pointerType","onTouchStart","style","position","touchAction","outputProps","map","join","$47b897dc8cdb026b$export$8d15029008292ae","opts","isRequired","validationState","inputRef","labelId","ref1","trim","focusInput","$fA3fN$useCallback","$fA3fN$focusWithoutScrolling","isFocused","focusedThumb","$fA3fN$useEffect","keyboardProps","$fA3fN$useKeyboard","onKeyDown","getThumbMaxValue","getThumbMinValue","decrementThumb","incrementThumb","pageSize","test","key","continuePropagation","shiftKey","step","setThumbEditable","focusableProps","$fA3fN$useFocusable","onFocus","onBlur","onDown","onUp","thumbPosition","interactions","inputProps","type","tabIndex","min","max","disabled","getThumbValueLabel","onChange","parseFloat","target","thumbProps","transform","isDragging"],"sources":["/Users/k.chaganti/Desktop/b20/node_modules/@react-aria/slider/dist/packages/@react-aria/slider/src/utils.ts","/Users/k.chaganti/Desktop/b20/node_modules/@react-aria/slider/dist/packages/@react-aria/slider/src/useSlider.ts","/Users/k.chaganti/Desktop/b20/node_modules/@react-aria/slider/dist/packages/@react-aria/slider/src/useSliderThumb.ts"],"sourcesContent":["import {SliderState} from '@react-stately/slider';\n\nexport const sliderIds = new WeakMap<SliderState, string>();\n\nexport function getSliderThumbId(state: SliderState, index: number) {\n  let id = sliderIds.get(state);\n  if (!id) {\n    throw new Error('Unknown slider state');\n  }\n\n  return `${id}-${index}`;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaSliderProps} from '@react-types/slider';\nimport {clamp, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getSliderThumbId, sliderIds} from './utils';\nimport React, {LabelHTMLAttributes, OutputHTMLAttributes, RefObject, useRef} from 'react';\nimport {setInteractionModality, useMove} from '@react-aria/interactions';\nimport {SliderState} from '@react-stately/slider';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface SliderAria {\n  /** Props for the label element. */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Props for the root element of the slider component; groups slider inputs. */\n  groupProps: DOMAttributes,\n\n  /** Props for the track element. */\n  trackProps: DOMAttributes,\n\n  /** Props for the output element, displaying the value of the slider thumbs. */\n  outputProps: OutputHTMLAttributes<HTMLOutputElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\nexport function useSlider(\n  props: AriaSliderProps,\n  state: SliderState,\n  trackRef: RefObject<Element>\n): SliderAria {\n  let {labelProps, fieldProps} = useLabel(props);\n\n  let isVertical = props.orientation === 'vertical';\n\n  // Attach id of the label to the state so it can be accessed by useSliderThumb.\n  sliderIds.set(state, labelProps.id ?? fieldProps.id);\n\n  let {direction} = useLocale();\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n  const realTimeTrackDraggingIndex = useRef<number | null>(null);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  const reverseX = direction === 'rtl';\n  const currentPosition = useRef<number>(null);\n  const {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n    onMove({deltaX, deltaY}) {\n      let {height, width} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      }\n\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) {\n        delta = -delta;\n      }\n\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = clamp(currentPosition.current / size, 0, 1);\n        stateRef.current.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        stateRef.current.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  });\n\n  let currentPointer = useRef<number | null | undefined>(undefined);\n  let onDownTrack = (e: React.UIEvent, id: number, clientX: number, clientY: number) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let {height, width, top, left} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      // Find the closest thumb\n      const trackPosition = isVertical ? top : left;\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) {\n        percent = 1 - percent;\n      }\n      let value = state.getPercentValue(percent);\n\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) { // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) { // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      }\n\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else {\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  };\n\n  let onUpTrack = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if ('htmlFor' in labelProps && labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n    labelProps.onClick = () => {\n      // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      document.getElementById(getSliderThumbId(state, 0))?.focus();\n      setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: 'group',\n      ...fieldProps\n    },\n    trackProps: mergeProps({\n      onMouseDown(e: React.MouseEvent) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n      onPointerDown(e: React.PointerEvent) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n      onTouchStart(e: React.TouchEvent) { onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY); },\n      style: {\n        position: 'relative',\n        touchAction: 'none'\n      }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => getSliderThumbId(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n","import {AriaSliderThumbProps} from '@react-types/slider';\nimport {clamp, focusWithoutScrolling, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getSliderThumbId, sliderIds} from './utils';\nimport React, {ChangeEvent, InputHTMLAttributes, LabelHTMLAttributes, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {SliderState} from '@react-stately/slider';\nimport {useFocusable} from '@react-aria/focus';\nimport {useKeyboard, useMove} from '@react-aria/interactions';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: DOMAttributes,\n\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>,\n\n  /** Props for the label element for this thumb (optional). */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Whether this thumb is currently being dragged. */\n  isDragging: boolean,\n  /** Whether the thumb is currently focused. */\n  isFocused: boolean,\n  /** Whether the thumb is disabled. */\n  isDisabled: boolean\n}\n\nexport interface AriaSliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackRef: RefObject<Element>,\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: AriaSliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index,\n    isRequired,\n    validationState,\n    trackRef,\n    inputRef,\n    orientation = state.orientation\n  } = opts;\n\n  let isDisabled = opts.isDisabled || state.isDisabled;\n  let isVertical = orientation === 'vertical';\n\n  let {direction} = useLocale();\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let labelId = sliderIds.get(state);\n  const {labelProps, fieldProps} = useLabel({\n    ...opts,\n    id: getSliderThumbId(state, index),\n    'aria-labelledby': `${labelId} ${opts['aria-labelledby'] ?? ''}`.trim()\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n\n  let {keyboardProps} = useKeyboard({\n    onKeyDown(e) {\n      let {\n        getThumbMaxValue,\n        getThumbMinValue,\n        decrementThumb,\n        incrementThumb,\n        setThumbValue,\n        setThumbDragging,\n        pageSize\n      } = stateRef.current;\n      // these are the cases that useMove or useSlider don't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, stopPropagation to prevent useSlider from handling the event as well.\n      e.preventDefault();\n      // remember to set this so that onChangeEnd is fired\n      setThumbDragging(index, true);\n      switch (e.key) {\n        case 'PageUp':\n          incrementThumb(index, pageSize);\n          break;\n        case 'PageDown':\n          decrementThumb(index, pageSize);\n          break;\n        case 'Home':\n          setThumbValue(index, getThumbMinValue(index));\n          break;\n        case 'End':\n          setThumbValue(index, getThumbMaxValue(index));\n          break;\n      }\n      setThumbDragging(index, false);\n    }\n  });\n\n  let {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      stateRef.current.setThumbDragging(index, true);\n    },\n    onMove({deltaX, deltaY, pointerType, shiftKey}) {\n      const {\n        getThumbPercent,\n        setThumbPercent,\n        decrementThumb,\n        incrementThumb,\n        step,\n        pageSize\n      } = stateRef.current;\n      let {width, height} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        if ((deltaX > 0 && reverseX) || (deltaX < 0 && !reverseX) || deltaY > 0) {\n          decrementThumb(index, shiftKey ? pageSize : step);\n        } else {\n          incrementThumb(index, shiftKey ? pageSize : step);\n        }\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n\n        currentPosition.current += delta;\n        setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd() {\n      stateRef.current.setThumbDragging(index, false);\n    }\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const {focusableProps} = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined)\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | undefined>(undefined);\n  let onDown = (id?: number) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  let thumbPosition = state.getThumbPercent(index);\n  if (isVertical || direction === 'rtl') {\n    thumbPosition = 1 - thumbPosition;\n  }\n\n  let interactions = !isDisabled ? mergeProps(\n    keyboardProps,\n    moveProps,\n    {\n      onMouseDown: (e: React.MouseEvent) => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown();\n      },\n      onPointerDown: (e: React.PointerEvent) => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown(e.pointerId);\n      },\n      onTouchStart: (e: React.TouchEvent) => {onDown(e.changedTouches[0].identifier);}\n    }\n  ) : {};\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      disabled: isDisabled,\n      'aria-orientation': orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      onChange: (e: ChangeEvent<HTMLInputElement>) => {\n        stateRef.current.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: {\n      ...interactions,\n      style: {\n        position: 'absolute',\n        [isVertical ? 'top' : 'left']: `${thumbPosition * 100}%`,\n        transform: 'translate(-50%, -50%)',\n        touchAction: 'none'\n      }\n    },\n    labelProps,\n    isDragging: state.isThumbDragging(index),\n    isDisabled,\n    isFocused\n  };\n}\n"]},"metadata":{},"sourceType":"module"}