{"ast":null,"code":"import { filterDOMProps as $thkiX$filterDOMProps, mergeProps as $thkiX$mergeProps, useId as $thkiX$useId, chain as $thkiX$chain } from \"@react-aria/utils\";\nimport $thkiX$react, { useMemo as $thkiX$useMemo } from \"react\";\nimport { ListKeyboardDelegate as $thkiX$ListKeyboardDelegate, useTypeSelect as $thkiX$useTypeSelect } from \"@react-aria/selection\";\nimport { setInteractionModality as $thkiX$setInteractionModality, useInteractionModality as $thkiX$useInteractionModality } from \"@react-aria/interactions\";\nimport { useCollator as $thkiX$useCollator } from \"@react-aria/i18n\";\nimport { useField as $thkiX$useField } from \"@react-aria/label\";\nimport { useMenuTrigger as $thkiX$useMenuTrigger } from \"@react-aria/menu\";\nimport { useVisuallyHidden as $thkiX$useVisuallyHidden } from \"@react-aria/visually-hidden\";\n\nfunction $58aed456727eb0f3$export$e64b2f635402ca43(props, state, ref) {\n  let {\n    keyboardDelegate: keyboardDelegate,\n    isDisabled: isDisabled\n  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n\n  let collator = $thkiX$useCollator({\n    usage: 'search',\n    sensitivity: 'base'\n  });\n  let delegate = $thkiX$useMemo(() => keyboardDelegate || new $thkiX$ListKeyboardDelegate(state.collection, state.disabledKeys, null, collator), [keyboardDelegate, state.collection, state.disabledKeys, collator]);\n  let {\n    menuTriggerProps: menuTriggerProps,\n    menuProps: menuProps\n  } = $thkiX$useMenuTrigger({\n    isDisabled: isDisabled,\n    type: 'listbox'\n  }, state, ref);\n\n  let onKeyDown = e => {\n    switch (e.key) {\n      case 'ArrowLeft':\n        {\n          // prevent scrolling containers\n          e.preventDefault();\n          let key = state.selectedKey != null ? delegate.getKeyAbove(state.selectedKey) : delegate.getFirstKey();\n          if (key) state.setSelectedKey(key);\n          break;\n        }\n\n      case 'ArrowRight':\n        {\n          // prevent scrolling containers\n          e.preventDefault();\n          let key = state.selectedKey != null ? delegate.getKeyBelow(state.selectedKey) : delegate.getFirstKey();\n          if (key) state.setSelectedKey(key);\n          break;\n        }\n    }\n  };\n\n  let {\n    typeSelectProps: typeSelectProps\n  } = $thkiX$useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: state.selectionManager,\n\n    onTypeSelect(key) {\n      state.setSelectedKey(key);\n    }\n\n  });\n  let {\n    labelProps: labelProps,\n    fieldProps: fieldProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  } = $thkiX$useField({ ...props,\n    labelElementType: 'span'\n  });\n  typeSelectProps.onKeyDown = typeSelectProps.onKeyDownCapture;\n  delete typeSelectProps.onKeyDownCapture;\n  let domProps = $thkiX$filterDOMProps(props, {\n    labelable: true\n  });\n  let triggerProps = $thkiX$mergeProps(typeSelectProps, menuTriggerProps, fieldProps);\n  let valueId = $thkiX$useId();\n  return {\n    labelProps: { ...labelProps,\n      onClick: () => {\n        if (!props.isDisabled) {\n          ref.current.focus(); // Show the focus ring so the user knows where focus went\n\n          $thkiX$setInteractionModality('keyboard');\n        }\n      }\n    },\n    triggerProps: $thkiX$mergeProps(domProps, { ...triggerProps,\n      isDisabled: isDisabled,\n      onKeyDown: $thkiX$chain(triggerProps.onKeyDown, onKeyDown, props.onKeyDown),\n      onKeyUp: props.onKeyUp,\n      'aria-labelledby': [triggerProps['aria-labelledby'], triggerProps['aria-label'] && !triggerProps['aria-labelledby'] ? triggerProps.id : null, valueId].filter(Boolean).join(' '),\n\n      onFocus(e) {\n        if (state.isFocused) return;\n        if (props.onFocus) props.onFocus(e);\n        if (props.onFocusChange) props.onFocusChange(true);\n        state.setFocused(true);\n      },\n\n      onBlur(e) {\n        if (state.isOpen) return;\n        if (props.onBlur) props.onBlur(e);\n        if (props.onFocusChange) props.onFocusChange(false);\n        state.setFocused(false);\n      }\n\n    }),\n    valueProps: {\n      id: valueId\n    },\n    menuProps: { ...menuProps,\n      autoFocus: state.focusStrategy || true,\n      shouldSelectOnPressUp: true,\n      shouldFocusOnHover: true,\n      disallowEmptySelection: true,\n      onBlur: e => {\n        if (e.currentTarget.contains(e.relatedTarget)) return;\n        if (props.onBlur) props.onBlur(e);\n        if (props.onFocusChange) props.onFocusChange(false);\n        state.setFocused(false);\n      },\n      'aria-labelledby': [fieldProps['aria-labelledby'], triggerProps['aria-label'] && !fieldProps['aria-labelledby'] ? triggerProps.id : null].filter(Boolean).join(' ')\n    },\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  };\n}\n\nfunction $bdd25dc72710631f$export$f809e80f58e251d1(props, state, triggerRef) {\n  let {\n    autoComplete: autoComplete,\n    name: name,\n    isDisabled: isDisabled\n  } = props;\n  let modality = $thkiX$useInteractionModality();\n  let {\n    visuallyHiddenProps: visuallyHiddenProps\n  } = $thkiX$useVisuallyHidden();\n\n  var _selectedKey; // In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.\n  // In Firefox, there must be a <label> to identify the <select> whereas other browsers\n  // seem to identify it just by surrounding text.\n  // The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a\n  // 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>\n  // non tabbable with tabIndex={-1}.\n  //\n  // In mobile browsers, there are next/previous buttons above the software keyboard for navigating\n  // between fields in a form. These only support native form inputs that are tabbable. In order to\n  // support those, an additional hidden input is used to marshall focus to the button. It is tabbable\n  // except when the button is focused, so that shift tab works properly to go to the actual previous\n  // input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes\n  // the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to\n  // prevent Safari from zooming in on the input when it is focused.\n  //\n  // If the current interaction modality is null, then the user hasn't interacted with the page yet.\n  // In this case, we set the tabIndex to -1 on the input element so that automated accessibility\n  // checkers don't throw false-positives about focusable elements inside an aria-hidden parent.\n\n\n  return {\n    containerProps: { ...visuallyHiddenProps,\n      'aria-hidden': true\n    },\n    inputProps: {\n      type: 'text',\n      tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,\n      style: {\n        fontSize: 16\n      },\n      onFocus: () => triggerRef.current.focus(),\n      disabled: isDisabled\n    },\n    selectProps: {\n      tabIndex: -1,\n      autoComplete: autoComplete,\n      disabled: isDisabled,\n      name: name,\n      size: state.collection.size,\n      value: (_selectedKey = state.selectedKey) !== null && _selectedKey !== void 0 ? _selectedKey : '',\n      onChange: e => state.setSelectedKey(e.target.value)\n    }\n  };\n}\n\nfunction $bdd25dc72710631f$export$cbd84cdb2e668835(props) {\n  let {\n    state: state,\n    triggerRef: triggerRef,\n    label: label,\n    name: name,\n    isDisabled: isDisabled\n  } = props;\n  let {\n    containerProps: containerProps,\n    inputProps: inputProps,\n    selectProps: selectProps\n  } = $bdd25dc72710631f$export$f809e80f58e251d1(props, state, triggerRef); // If used in a <form>, use a hidden input so the value can be submitted to a server.\n  // If the collection isn't too big, use a hidden <select> element for this so that browser\n  // autofill will work. Otherwise, use an <input type=\"hidden\">.\n\n  if (state.collection.size <= 300) return /*#__PURE__*/$thkiX$react.createElement(\"div\", containerProps, /*#__PURE__*/$thkiX$react.createElement(\"input\", inputProps), /*#__PURE__*/$thkiX$react.createElement(\"label\", null, label, /*#__PURE__*/$thkiX$react.createElement(\"select\", selectProps, /*#__PURE__*/$thkiX$react.createElement(\"option\", null), [...state.collection.getKeys()].map(key => {\n    let item = state.collection.getItem(key);\n    if (item.type === 'item') return /*#__PURE__*/$thkiX$react.createElement(\"option\", {\n      key: item.key,\n      value: item.key\n    }, item.textValue);\n  }))));else if (name) return /*#__PURE__*/$thkiX$react.createElement(\"input\", {\n    type: \"hidden\",\n    autoComplete: selectProps.autoComplete,\n    name: name,\n    disabled: isDisabled,\n    value: state.selectedKey\n  });\n  return null;\n}\n\nexport { $58aed456727eb0f3$export$e64b2f635402ca43 as useSelect, $bdd25dc72710631f$export$f809e80f58e251d1 as useHiddenSelect, $bdd25dc72710631f$export$cbd84cdb2e668835 as HiddenSelect };","map":{"version":3,"mappings":"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","names":["$58aed456727eb0f3$export$e64b2f635402ca43","props","state","ref","keyboardDelegate","isDisabled","collator","$thkiX$useCollator","usage","sensitivity","delegate","$thkiX$useMemo","$thkiX$ListKeyboardDelegate","collection","disabledKeys","menuTriggerProps","menuProps","$thkiX$useMenuTrigger","type","onKeyDown","e","key","preventDefault","selectedKey","getKeyAbove","getFirstKey","setSelectedKey","getKeyBelow","typeSelectProps","$thkiX$useTypeSelect","selectionManager","onTypeSelect","labelProps","fieldProps","descriptionProps","errorMessageProps","$thkiX$useField","labelElementType","onKeyDownCapture","domProps","$thkiX$filterDOMProps","labelable","triggerProps","$thkiX$mergeProps","valueId","$thkiX$useId","onClick","current","focus","$thkiX$setInteractionModality","$thkiX$chain","onKeyUp","id","filter","Boolean","join","onFocus","isFocused","onFocusChange","setFocused","onBlur","isOpen","valueProps","autoFocus","focusStrategy","shouldSelectOnPressUp","shouldFocusOnHover","disallowEmptySelection","currentTarget","contains","relatedTarget","$bdd25dc72710631f$export$f809e80f58e251d1","triggerRef","autoComplete","name","modality","$thkiX$useInteractionModality","visuallyHiddenProps","$thkiX$useVisuallyHidden","_selectedKey","containerProps","inputProps","tabIndex","style","fontSize","disabled","selectProps","size","value","onChange","target","$bdd25dc72710631f$export$cbd84cdb2e668835","label","getKeys","map","item","getItem","textValue"],"sources":["/Users/k.chaganti/Desktop/b20/node_modules/@react-aria/select/dist/packages/@react-aria/select/src/useSelect.ts","/Users/k.chaganti/Desktop/b20/node_modules/@react-aria/select/dist/packages/@react-aria/select/src/HiddenSelect.tsx"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaButtonProps} from '@react-types/button';\nimport {AriaListBoxOptions} from '@react-aria/listbox';\nimport {AriaSelectProps} from '@react-types/select';\nimport {chain, filterDOMProps, mergeProps, useId} from '@react-aria/utils';\nimport {DOMAttributes, FocusableElement, KeyboardDelegate} from '@react-types/shared';\nimport {FocusEvent, RefObject, useMemo} from 'react';\nimport {ListKeyboardDelegate, useTypeSelect} from '@react-aria/selection';\nimport {SelectState} from '@react-stately/select';\nimport {setInteractionModality} from '@react-aria/interactions';\nimport {useCollator} from '@react-aria/i18n';\nimport {useField} from '@react-aria/label';\nimport {useMenuTrigger} from '@react-aria/menu';\n\nexport interface AriaSelectOptions<T> extends AriaSelectProps<T> {\n  /**\n   * An optional keyboard delegate implementation for type to select,\n   * to override the default.\n   */\n  keyboardDelegate?: KeyboardDelegate\n}\n\nexport interface SelectAria<T> {\n  /** Props for the label element. */\n  labelProps: DOMAttributes,\n\n  /** Props for the popup trigger element. */\n  triggerProps: AriaButtonProps,\n\n  /** Props for the element representing the selected value. */\n  valueProps: DOMAttributes,\n\n  /** Props for the popup. */\n  menuProps: AriaListBoxOptions<T>,\n\n  /** Props for the select's description element, if any. */\n  descriptionProps: DOMAttributes,\n\n  /** Props for the select's error message element, if any. */\n  errorMessageProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a select component.\n * A select displays a collapsible list of options and allows a user to select one of them.\n * @param props - Props for the select.\n * @param state - State for the select, as returned by `useListState`.\n */\nexport function useSelect<T>(props: AriaSelectOptions<T>, state: SelectState<T>, ref: RefObject<FocusableElement>): SelectAria<T> {\n  let {\n    keyboardDelegate,\n    isDisabled\n  } = props;\n\n  // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n  let collator = useCollator({usage: 'search', sensitivity: 'base'});\n  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(state.collection, state.disabledKeys, null, collator), [keyboardDelegate, state.collection, state.disabledKeys, collator]);\n\n  let {menuTriggerProps, menuProps} = useMenuTrigger<T>(\n    {\n      isDisabled,\n      type: 'listbox'\n    },\n    state,\n    ref\n  );\n\n  let onKeyDown = (e: KeyboardEvent) => {\n    switch (e.key) {\n      case 'ArrowLeft': {\n        // prevent scrolling containers\n        e.preventDefault();\n\n        let key = state.selectedKey != null ? delegate.getKeyAbove(state.selectedKey) : delegate.getFirstKey();\n        if (key) {\n          state.setSelectedKey(key);\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        // prevent scrolling containers\n        e.preventDefault();\n\n        let key = state.selectedKey != null ? delegate.getKeyBelow(state.selectedKey) : delegate.getFirstKey();\n        if (key) {\n          state.setSelectedKey(key);\n        }\n        break;\n      }\n    }\n  };\n\n  let {typeSelectProps} = useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: state.selectionManager,\n    onTypeSelect(key) {\n      state.setSelectedKey(key);\n    }\n  });\n\n  let {labelProps, fieldProps, descriptionProps, errorMessageProps} = useField({\n    ...props,\n    labelElementType: 'span'\n  });\n\n  typeSelectProps.onKeyDown = typeSelectProps.onKeyDownCapture;\n  delete typeSelectProps.onKeyDownCapture;\n\n  let domProps = filterDOMProps(props, {labelable: true});\n  let triggerProps = mergeProps(typeSelectProps, menuTriggerProps, fieldProps);\n\n  let valueId = useId();\n\n  return {\n    labelProps: {\n      ...labelProps,\n      onClick: () => {\n        if (!props.isDisabled) {\n          ref.current.focus();\n\n          // Show the focus ring so the user knows where focus went\n          setInteractionModality('keyboard');\n        }\n      }\n    },\n    triggerProps: mergeProps(domProps, {\n      ...triggerProps,\n      isDisabled,\n      onKeyDown: chain(triggerProps.onKeyDown, onKeyDown, props.onKeyDown),\n      onKeyUp: props.onKeyUp,\n      'aria-labelledby': [\n        triggerProps['aria-labelledby'],\n        triggerProps['aria-label'] && !triggerProps['aria-labelledby'] ? triggerProps.id : null,\n        valueId\n      ].filter(Boolean).join(' '),\n      onFocus(e: FocusEvent) {\n        if (state.isFocused) {\n          return;\n        }\n\n        if (props.onFocus) {\n          props.onFocus(e);\n        }\n\n        if (props.onFocusChange) {\n          props.onFocusChange(true);\n        }\n\n        state.setFocused(true);\n      },\n      onBlur(e: FocusEvent) {\n        if (state.isOpen) {\n          return;\n        }\n\n        if (props.onBlur) {\n          props.onBlur(e);\n        }\n\n        if (props.onFocusChange) {\n          props.onFocusChange(false);\n        }\n\n        state.setFocused(false);\n      }\n    }),\n    valueProps: {\n      id: valueId\n    },\n    menuProps: {\n      ...menuProps,\n      autoFocus: state.focusStrategy || true,\n      shouldSelectOnPressUp: true,\n      shouldFocusOnHover: true,\n      disallowEmptySelection: true,\n      onBlur: (e) => {\n        if (e.currentTarget.contains(e.relatedTarget as Node)) {\n          return;\n        }\n\n        if (props.onBlur) {\n          props.onBlur(e);\n        }\n\n        if (props.onFocusChange) {\n          props.onFocusChange(false);\n        }\n\n        state.setFocused(false);\n      },\n      'aria-labelledby': [\n        fieldProps['aria-labelledby'],\n        triggerProps['aria-label'] && !fieldProps['aria-labelledby'] ? triggerProps.id : null\n      ].filter(Boolean).join(' ')\n    },\n    descriptionProps,\n    errorMessageProps\n  };\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {FocusableElement} from '@react-types/shared';\nimport React, {ReactNode, RefObject} from 'react';\nimport {SelectState} from '@react-stately/select';\nimport {useInteractionModality} from '@react-aria/interactions';\nimport {useVisuallyHidden} from '@react-aria/visually-hidden';\n\nexport interface AriaHiddenSelectProps {\n  /**\n   * Describes the type of autocomplete functionality the input should provide if any. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefautocomplete).\n   */\n   autoComplete?: string,\n\n  /** The text label for the select. */\n  label?: ReactNode,\n\n  /** HTML form input name. */\n  name?: string,\n\n  /** Sets the disabled state of the select and input. */\n  isDisabled?: boolean\n}\n\nexport interface HiddenSelectProps<T> extends AriaHiddenSelectProps {\n  /** State for the select. */\n  state: SelectState<T>,\n\n  /** A ref to the trigger element. */\n  triggerRef: RefObject<FocusableElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a hidden `<select>` element, which\n * can be used in combination with `useSelect` to support browser form autofill, mobile form\n * navigation, and native HTML form submission.\n */\nexport function useHiddenSelect<T>(props: AriaHiddenSelectProps, state: SelectState<T>, triggerRef: RefObject<FocusableElement>) {\n  let {autoComplete, name, isDisabled} = props;\n  let modality = useInteractionModality();\n  let {visuallyHiddenProps} = useVisuallyHidden();\n\n  // In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.\n  // In Firefox, there must be a <label> to identify the <select> whereas other browsers\n  // seem to identify it just by surrounding text.\n  // The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a\n  // 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>\n  // non tabbable with tabIndex={-1}.\n  //\n  // In mobile browsers, there are next/previous buttons above the software keyboard for navigating\n  // between fields in a form. These only support native form inputs that are tabbable. In order to\n  // support those, an additional hidden input is used to marshall focus to the button. It is tabbable\n  // except when the button is focused, so that shift tab works properly to go to the actual previous\n  // input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes\n  // the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to\n  // prevent Safari from zooming in on the input when it is focused.\n  //\n  // If the current interaction modality is null, then the user hasn't interacted with the page yet.\n  // In this case, we set the tabIndex to -1 on the input element so that automated accessibility\n  // checkers don't throw false-positives about focusable elements inside an aria-hidden parent.\n  return {\n    containerProps: {\n      ...visuallyHiddenProps,\n      'aria-hidden': true\n    },\n    inputProps: {\n      type: 'text',\n      tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,\n      style: {fontSize: 16},\n      onFocus: () => triggerRef.current.focus(),\n      disabled: isDisabled\n    },\n    selectProps: {\n      tabIndex: -1,\n      autoComplete,\n      disabled: isDisabled,\n      name,\n      size: state.collection.size,\n      value: state.selectedKey ?? '',\n      onChange: (e: React.ChangeEvent<HTMLSelectElement>) => state.setSelectedKey(e.target.value)\n    }\n  };\n}\n\n/**\n * Renders a hidden native `<select>` element, which can be used to support browser\n * form autofill, mobile form navigation, and native form submission.\n */\nexport function HiddenSelect<T>(props: HiddenSelectProps<T>) {\n  let {state, triggerRef, label, name, isDisabled} = props;\n  let {containerProps, inputProps, selectProps} = useHiddenSelect(props, state, triggerRef);\n\n  // If used in a <form>, use a hidden input so the value can be submitted to a server.\n  // If the collection isn't too big, use a hidden <select> element for this so that browser\n  // autofill will work. Otherwise, use an <input type=\"hidden\">.\n  if (state.collection.size <= 300) {\n    return (\n      <div {...containerProps}>\n        <input {...inputProps} />\n        <label>\n          {label}\n          <select {...selectProps}>\n            <option />\n            {[...state.collection.getKeys()].map(key => {\n              let item = state.collection.getItem(key);\n              if (item.type === 'item') {\n                return (\n                  <option\n                    key={item.key}\n                    value={item.key}>\n                    {item.textValue}\n                  </option>\n                );\n              }\n            })}\n          </select>\n        </label>\n      </div>\n    );\n  } else if (name) {\n    return (\n      <input\n        type=\"hidden\"\n        autoComplete={selectProps.autoComplete}\n        name={name}\n        disabled={isDisabled}\n        value={state.selectedKey} />\n    );\n  }\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}