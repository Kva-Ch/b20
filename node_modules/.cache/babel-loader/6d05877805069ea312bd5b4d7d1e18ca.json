{"ast":null,"code":"import _defineProperty from \"/Users/s.gollapalli/Desktop/project/b20-master-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"/Users/s.gollapalli/Desktop/project/b20-master-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport { useGlobalListeners as $fA3fN$useGlobalListeners, clamp as $fA3fN$clamp, mergeProps as $fA3fN$mergeProps, focusWithoutScrolling as $fA3fN$focusWithoutScrolling } from \"@react-aria/utils\";\nimport { useRef as $fA3fN$useRef, useCallback as $fA3fN$useCallback, useEffect as $fA3fN$useEffect } from \"react\";\nimport { useMove as $fA3fN$useMove, setInteractionModality as $fA3fN$setInteractionModality, useKeyboard as $fA3fN$useKeyboard } from \"@react-aria/interactions\";\nimport { useLabel as $fA3fN$useLabel } from \"@react-aria/label\";\nimport { useLocale as $fA3fN$useLocale } from \"@react-aria/i18n\";\nimport { useFocusable as $fA3fN$useFocusable } from \"@react-aria/focus\";\nvar $aa519ee6cf463259$export$7a8d2b02c9371cbf = new WeakMap();\n\nfunction $aa519ee6cf463259$export$68e648cbec363a18(state, index) {\n  var id = $aa519ee6cf463259$export$7a8d2b02c9371cbf.get(state);\n  if (!id) throw new Error('Unknown slider state');\n  return \"\".concat(id, \"-\").concat(index);\n}\n\nfunction $bcca50147b47f54d$export$56b2c08e277f365(props, state, trackRef) {\n  var _$fA3fN$useLabel = $fA3fN$useLabel(props),\n      labelProps = _$fA3fN$useLabel.labelProps,\n      fieldProps = _$fA3fN$useLabel.fieldProps;\n\n  var isVertical = props.orientation === 'vertical';\n\n  var _id; // Attach id of the label to the state so it can be accessed by useSliderThumb.\n\n\n  $aa519ee6cf463259$export$7a8d2b02c9371cbf.set(state, (_id = labelProps.id) !== null && _id !== void 0 ? _id : fieldProps.id);\n\n  var _$fA3fN$useLocale = $fA3fN$useLocale(),\n      direction = _$fA3fN$useLocale.direction;\n\n  var _$fA3fN$useGlobalList = $fA3fN$useGlobalListeners(),\n      addGlobalListener = _$fA3fN$useGlobalList.addGlobalListener,\n      removeGlobalListener = _$fA3fN$useGlobalList.removeGlobalListener; // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n\n\n  var realTimeTrackDraggingIndex = $fA3fN$useRef(null);\n  var stateRef = $fA3fN$useRef(null);\n  stateRef.current = state;\n  var reverseX = direction === 'rtl';\n  var currentPosition = $fA3fN$useRef(null);\n\n  var _$fA3fN$useMove = $fA3fN$useMove({\n    onMoveStart: function onMoveStart() {\n      currentPosition.current = null;\n    },\n    onMove: function onMove(_ref) {\n      var deltaX = _ref.deltaX,\n          deltaY = _ref.deltaY;\n\n      var _trackRef$current$get = trackRef.current.getBoundingClientRect(),\n          height = _trackRef$current$get.height,\n          width = _trackRef$current$get.width;\n\n      var size = isVertical ? height : width;\n      if (currentPosition.current == null) currentPosition.current = stateRef.current.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      var delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) delta = -delta;\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        var percent = $fA3fN$clamp(currentPosition.current / size, 0, 1);\n        stateRef.current.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n    onMoveEnd: function onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        stateRef.current.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  }),\n      moveProps = _$fA3fN$useMove.moveProps;\n\n  var currentPointer = $fA3fN$useRef(undefined);\n\n  var onDownTrack = function onDownTrack(e, id, clientX, clientY) {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every(function (_, i) {\n      return !state.isThumbDragging(i);\n    })) {\n      var _trackRef$current$get2 = trackRef.current.getBoundingClientRect(),\n          height = _trackRef$current$get2.height,\n          width = _trackRef$current$get2.width,\n          top = _trackRef$current$get2.top,\n          left = _trackRef$current$get2.left;\n\n      var size = isVertical ? height : width; // Find the closest thumb\n\n      var trackPosition = isVertical ? top : left;\n      var clickPosition = isVertical ? clientY : clientX;\n      var offset = clickPosition - trackPosition;\n      var percent = offset / size;\n      if (direction === 'rtl' || isVertical) percent = 1 - percent;\n      var value = state.getPercentValue(percent); // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n\n      var closestThumb;\n      var split = state.values.findIndex(function (v) {\n        return value - v < 0;\n      });\n      if (split === 0) closestThumb = split;else if (split === -1) closestThumb = state.values.length - 1;else {\n        var lastLeft = state.values[split - 1];\n        var firstRight = state.values[split]; // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) closestThumb = split - 1;else closestThumb = split;\n      } // Confirm that the found closest thumb is editable, not disabled, and move it\n\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else realTimeTrackDraggingIndex.current = null;\n    }\n  };\n\n  var onUpTrack = function onUpTrack(e) {\n    var ref;\n\n    var _pointerId;\n\n    var id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;\n\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if ('htmlFor' in labelProps && labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n\n    labelProps.onClick = function () {\n      var // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      ref;\n      (ref = document.getElementById($aa519ee6cf463259$export$68e648cbec363a18(state, 0))) === null || ref === void 0 ? void 0 : ref.focus();\n      $fA3fN$setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps: labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: _objectSpread({\n      role: 'group'\n    }, fieldProps),\n    trackProps: $fA3fN$mergeProps({\n      onMouseDown: function onMouseDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n      onPointerDown: function onPointerDown(e) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) return;\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n      onTouchStart: function onTouchStart(e) {\n        onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY);\n      },\n      style: {\n        position: 'relative',\n        touchAction: 'none'\n      }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map(function (_, index) {\n        return $aa519ee6cf463259$export$68e648cbec363a18(state, index);\n      }).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n\nfunction $47b897dc8cdb026b$export$8d15029008292ae(opts, state) {\n  var _style;\n\n  var index = opts.index,\n      isRequired = opts.isRequired,\n      validationState = opts.validationState,\n      trackRef = opts.trackRef,\n      inputRef = opts.inputRef,\n      _opts$orientation = opts.orientation,\n      orientation = _opts$orientation === void 0 ? state.orientation : _opts$orientation;\n  var isDisabled = opts.isDisabled || state.isDisabled;\n  var isVertical = orientation === 'vertical';\n\n  var _$fA3fN$useLocale2 = $fA3fN$useLocale(),\n      direction = _$fA3fN$useLocale2.direction;\n\n  var _$fA3fN$useGlobalList2 = $fA3fN$useGlobalListeners(),\n      addGlobalListener = _$fA3fN$useGlobalList2.addGlobalListener,\n      removeGlobalListener = _$fA3fN$useGlobalList2.removeGlobalListener;\n\n  var labelId = $aa519ee6cf463259$export$7a8d2b02c9371cbf.get(state);\n  var ref1;\n\n  var _$fA3fN$useLabel2 = $fA3fN$useLabel(_objectSpread({}, opts, {\n    id: $aa519ee6cf463259$export$68e648cbec363a18(state, index),\n    'aria-labelledby': \"\".concat(labelId, \" \").concat((ref1 = opts['aria-labelledby']) !== null && ref1 !== void 0 ? ref1 : '').trim()\n  })),\n      labelProps = _$fA3fN$useLabel2.labelProps,\n      fieldProps = _$fA3fN$useLabel2.fieldProps;\n\n  var value = state.values[index];\n  var focusInput = $fA3fN$useCallback(function () {\n    if (inputRef.current) $fA3fN$focusWithoutScrolling(inputRef.current);\n  }, [inputRef]);\n  var isFocused = state.focusedThumb === index;\n  $fA3fN$useEffect(function () {\n    if (isFocused) focusInput();\n  }, [isFocused, focusInput]);\n  var stateRef = $fA3fN$useRef(null);\n  stateRef.current = state;\n  var reverseX = direction === 'rtl';\n  var currentPosition = $fA3fN$useRef(null);\n\n  var _$fA3fN$useKeyboard = $fA3fN$useKeyboard({\n    onKeyDown: function onKeyDown(e) {\n      var _stateRef$current = stateRef.current,\n          getThumbMaxValue = _stateRef$current.getThumbMaxValue,\n          getThumbMinValue = _stateRef$current.getThumbMinValue,\n          decrementThumb = _stateRef$current.decrementThumb,\n          incrementThumb = _stateRef$current.incrementThumb,\n          setThumbValue = _stateRef$current.setThumbValue,\n          setThumbDragging = _stateRef$current.setThumbDragging,\n          pageSize = _stateRef$current.pageSize; // these are the cases that useMove or useSlider don't handle\n\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      } // same handling as useMove, stopPropagation to prevent useSlider from handling the event as well.\n\n\n      e.preventDefault(); // remember to set this so that onChangeEnd is fired\n\n      setThumbDragging(index, true);\n\n      switch (e.key) {\n        case 'PageUp':\n          incrementThumb(index, pageSize);\n          break;\n\n        case 'PageDown':\n          decrementThumb(index, pageSize);\n          break;\n\n        case 'Home':\n          setThumbValue(index, getThumbMinValue(index));\n          break;\n\n        case 'End':\n          setThumbValue(index, getThumbMaxValue(index));\n          break;\n      }\n\n      setThumbDragging(index, false);\n    }\n  }),\n      keyboardProps = _$fA3fN$useKeyboard.keyboardProps;\n\n  var _$fA3fN$useMove2 = $fA3fN$useMove({\n    onMoveStart: function onMoveStart() {\n      currentPosition.current = null;\n      stateRef.current.setThumbDragging(index, true);\n    },\n    onMove: function onMove(_ref2) {\n      var deltaX = _ref2.deltaX,\n          deltaY = _ref2.deltaY,\n          pointerType = _ref2.pointerType,\n          shiftKey = _ref2.shiftKey;\n      var _stateRef$current2 = stateRef.current,\n          getThumbPercent = _stateRef$current2.getThumbPercent,\n          setThumbPercent = _stateRef$current2.setThumbPercent,\n          decrementThumb = _stateRef$current2.decrementThumb,\n          incrementThumb = _stateRef$current2.incrementThumb,\n          step = _stateRef$current2.step,\n          pageSize = _stateRef$current2.pageSize;\n\n      var _trackRef$current$get3 = trackRef.current.getBoundingClientRect(),\n          width = _trackRef$current$get3.width,\n          height = _trackRef$current$get3.height;\n\n      var size = isVertical ? height : width;\n      if (currentPosition.current == null) currentPosition.current = getThumbPercent(index) * size;\n\n      if (pointerType === 'keyboard') {\n        if (deltaX > 0 && reverseX || deltaX < 0 && !reverseX || deltaY > 0) decrementThumb(index, shiftKey ? pageSize : step);else incrementThumb(index, shiftKey ? pageSize : step);\n      } else {\n        var delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) delta = -delta;\n        currentPosition.current += delta;\n        setThumbPercent(index, $fA3fN$clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd: function onMoveEnd() {\n      stateRef.current.setThumbDragging(index, false);\n    }\n  }),\n      moveProps = _$fA3fN$useMove2.moveProps; // Immediately register editability with the state\n\n\n  state.setThumbEditable(index, !isDisabled);\n\n  var _$fA3fN$useFocusable = $fA3fN$useFocusable($fA3fN$mergeProps(opts, {\n    onFocus: function onFocus() {\n      return state.setFocusedThumb(index);\n    },\n    onBlur: function onBlur() {\n      return state.setFocusedThumb(undefined);\n    }\n  }), inputRef),\n      focusableProps = _$fA3fN$useFocusable.focusableProps;\n\n  var currentPointer = $fA3fN$useRef(undefined);\n\n  var onDown = function onDown(id) {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  var onUp = function onUp(e) {\n    var ref;\n\n    var _pointerId;\n\n    var id = (_pointerId = e.pointerId) !== null && _pointerId !== void 0 ? _pointerId : (ref = e.changedTouches) === null || ref === void 0 ? void 0 : ref[0].identifier;\n\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  var thumbPosition = state.getThumbPercent(index);\n  if (isVertical || direction === 'rtl') thumbPosition = 1 - thumbPosition;\n  var interactions = !isDisabled ? $fA3fN$mergeProps(keyboardProps, moveProps, {\n    onMouseDown: function onMouseDown(e) {\n      if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n      onDown();\n    },\n    onPointerDown: function onPointerDown(e) {\n      if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) return;\n      onDown(e.pointerId);\n    },\n    onTouchStart: function onTouchStart(e) {\n      onDown(e.changedTouches[0].identifier);\n    }\n  }) : {}; // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n\n  return {\n    inputProps: $fA3fN$mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      disabled: isDisabled,\n      'aria-orientation': orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      onChange: function onChange(e) {\n        stateRef.current.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: _objectSpread({}, interactions, {\n      style: (_style = {\n        position: 'absolute'\n      }, _defineProperty(_style, isVertical ? 'top' : 'left', \"\".concat(thumbPosition * 100, \"%\")), _defineProperty(_style, \"transform\", 'translate(-50%, -50%)'), _defineProperty(_style, \"touchAction\", 'none'), _style)\n    }),\n    labelProps: labelProps,\n    isDragging: state.isThumbDragging(index),\n    isDisabled: isDisabled,\n    isFocused: isFocused\n  };\n}\n\nexport { $bcca50147b47f54d$export$56b2c08e277f365 as useSlider, $47b897dc8cdb026b$export$8d15029008292ae as useSliderThumb };","map":null,"metadata":{},"sourceType":"module"}