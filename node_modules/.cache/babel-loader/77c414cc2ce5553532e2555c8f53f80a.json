{"ast":null,"code":"import _objectSpread from \"/Users/s.gollapalli/Desktop/project/b20-master-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport { filterDOMProps as $kOq5K$filterDOMProps, mergeProps as $kOq5K$mergeProps } from \"@react-aria/utils\";\nimport { useField as $kOq5K$useField } from \"@react-aria/label\";\nimport { useFocusable as $kOq5K$useFocusable } from \"@react-aria/focus\";\nimport { useRef as $kOq5K$useRef, useEffect as $kOq5K$useEffect } from \"react\";\n\nfunction $2d73ec29415bd339$export$712718f7aec83d5(props, ref) {\n  var _props$inputElementTy = props.inputElementType,\n      inputElementType = _props$inputElementTy === void 0 ? 'input' : _props$inputElementTy,\n      _props$isDisabled = props.isDisabled,\n      isDisabled = _props$isDisabled === void 0 ? false : _props$isDisabled,\n      _props$isRequired = props.isRequired,\n      isRequired = _props$isRequired === void 0 ? false : _props$isRequired,\n      _props$isReadOnly = props.isReadOnly,\n      isReadOnly = _props$isReadOnly === void 0 ? false : _props$isReadOnly,\n      validationState = props.validationState,\n      _props$type = props.type,\n      type = _props$type === void 0 ? 'text' : _props$type,\n      _props$onChange = props.onChange,\n      _onChange = _props$onChange === void 0 ? function () {} : _props$onChange;\n\n  var _$kOq5K$useFocusable = $kOq5K$useFocusable(props, ref),\n      focusableProps = _$kOq5K$useFocusable.focusableProps;\n\n  var _$kOq5K$useField = $kOq5K$useField(props),\n      labelProps = _$kOq5K$useField.labelProps,\n      fieldProps = _$kOq5K$useField.fieldProps,\n      descriptionProps = _$kOq5K$useField.descriptionProps,\n      errorMessageProps = _$kOq5K$useField.errorMessageProps;\n\n  var domProps = $kOq5K$filterDOMProps(props, {\n    labelable: true\n  });\n  var inputOnlyProps = {\n    type: type,\n    pattern: props.pattern\n  };\n  return {\n    labelProps: labelProps,\n    inputProps: $kOq5K$mergeProps(domProps, inputElementType === 'input' && inputOnlyProps, _objectSpread({\n      disabled: isDisabled,\n      readOnly: isReadOnly,\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': props['aria-errormessage'],\n      'aria-activedescendant': props['aria-activedescendant'],\n      'aria-autocomplete': props['aria-autocomplete'],\n      'aria-haspopup': props['aria-haspopup'],\n      value: props.value,\n      defaultValue: props.value ? undefined : props.defaultValue,\n      onChange: function onChange(e) {\n        return _onChange(e.target.value);\n      },\n      autoComplete: props.autoComplete,\n      maxLength: props.maxLength,\n      minLength: props.minLength,\n      name: props.name,\n      placeholder: props.placeholder,\n      inputMode: props.inputMode,\n      // Clipboard events\n      onCopy: props.onCopy,\n      onCut: props.onCut,\n      onPaste: props.onPaste,\n      // Composition events\n      onCompositionEnd: props.onCompositionEnd,\n      onCompositionStart: props.onCompositionStart,\n      onCompositionUpdate: props.onCompositionUpdate,\n      // Selection events\n      onSelect: props.onSelect,\n      // Input events\n      onBeforeInput: props.onBeforeInput,\n      onInput: props.onInput\n    }, focusableProps, fieldProps)),\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  };\n}\n\nfunction $d841c8010a73d545$var$supportsNativeBeforeInputEvent() {\n  return typeof window !== 'undefined' && window.InputEvent && // @ts-ignore\n  typeof InputEvent.prototype.getTargetRanges === 'function';\n}\n\nfunction $d841c8010a73d545$export$4f384c9210e583c3(props, state1, inputRef) {\n  var stateRef = $kOq5K$useRef(state1);\n  stateRef.current = state1; // All browsers implement the 'beforeinput' event natively except Firefox\n  // (currently behind a flag as of Firefox 84). React's polyfill does not\n  // run in all cases that the native event fires, e.g. when deleting text.\n  // Use the native event if available so that we can prevent invalid deletions.\n  // We do not attempt to polyfill this in Firefox since it would be very complicated,\n  // the benefit of doing so is fairly minor, and it's going to be natively supported soon.\n\n  $kOq5K$useEffect(function () {\n    if (!$d841c8010a73d545$var$supportsNativeBeforeInputEvent()) return;\n    var input = inputRef.current;\n\n    var onBeforeInput = function onBeforeInput(e) {\n      var state = stateRef.current; // Compute the next value of the input if the event is allowed to proceed.\n      // See https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes for a full list of input types.\n\n      var nextValue;\n\n      switch (e.inputType) {\n        case 'historyUndo':\n        case 'historyRedo':\n          // Explicitly allow undo/redo. e.data is null in this case, but there's no need to validate,\n          // because presumably the input would have already been validated previously.\n          return;\n\n        case 'deleteContent':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n\n        case 'deleteContentForward':\n          // This is potentially incorrect, since the browser may actually delete more than a single UTF-16\n          // character. In reality, a full Unicode grapheme cluster consisting of multiple UTF-16 characters\n          // or code points may be deleted. However, in our currently supported locales, there are no such cases.\n          // If we support additional locales in the future, this may need to change.\n          nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n\n        case 'deleteContentBackward':\n          nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n          break;\n\n        case 'deleteSoftLineBackward':\n        case 'deleteHardLineBackward':\n          nextValue = input.value.slice(input.selectionStart);\n          break;\n\n        default:\n          if (e.data != null) nextValue = input.value.slice(0, input.selectionStart) + e.data + input.value.slice(input.selectionEnd);\n          break;\n      } // If we did not compute a value, or the new value is invalid, prevent the event\n      // so that the browser does not update the input text, move the selection, or add to\n      // the undo/redo stack.\n\n\n      if (nextValue == null || !state.validate(nextValue)) e.preventDefault();\n    };\n\n    input.addEventListener('beforeinput', onBeforeInput, false);\n    return function () {\n      input.removeEventListener('beforeinput', onBeforeInput, false);\n    };\n  }, [inputRef, stateRef]);\n  var onBeforeInput1 = !$d841c8010a73d545$var$supportsNativeBeforeInputEvent() ? function (e) {\n    var nextValue = e.target.value.slice(0, e.target.selectionStart) + e.data + e.target.value.slice(e.target.selectionEnd);\n    if (!state1.validate(nextValue)) e.preventDefault();\n  } : null;\n\n  var _$2d73ec29415bd339$ex = $2d73ec29415bd339$export$712718f7aec83d5(props, inputRef),\n      labelProps = _$2d73ec29415bd339$ex.labelProps,\n      textFieldProps = _$2d73ec29415bd339$ex.inputProps,\n      descriptionProps = _$2d73ec29415bd339$ex.descriptionProps,\n      errorMessageProps = _$2d73ec29415bd339$ex.errorMessageProps;\n\n  var compositionStartState = $kOq5K$useRef(null);\n  return {\n    inputProps: $kOq5K$mergeProps(textFieldProps, {\n      onBeforeInput: onBeforeInput1,\n      onCompositionStart: function onCompositionStart() {\n        // Chrome does not implement Input Events Level 2, which specifies the insertFromComposition\n        // and deleteByComposition inputType values for the beforeinput event. These are meant to occur\n        // at the end of a composition (e.g. Pinyin IME, Android auto correct, etc.), and crucially, are\n        // cancelable. The insertCompositionText and deleteCompositionText input types are not cancelable,\n        // nor would we want to cancel them because the input from the user is incomplete at that point.\n        // In Safari, insertFromComposition/deleteFromComposition will fire, however, allowing us to cancel\n        // the final composition result if it is invalid. As a fallback for Chrome and Firefox, which either\n        // don't support Input Events Level 2, or beforeinput at all, we store the state of the input when\n        // the compositionstart event fires, and undo the changes in compositionend (below) if it is invalid.\n        // Unfortunately, this messes up the undo/redo stack, but until insertFromComposition/deleteByComposition\n        // are implemented, there is no other way to prevent composed input.\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=1022204\n        var _inputRef$current = inputRef.current,\n            value = _inputRef$current.value,\n            selectionStart = _inputRef$current.selectionStart,\n            selectionEnd = _inputRef$current.selectionEnd;\n        compositionStartState.current = {\n          value: value,\n          selectionStart: selectionStart,\n          selectionEnd: selectionEnd\n        };\n      },\n      onCompositionEnd: function onCompositionEnd() {\n        if (!state1.validate(inputRef.current.value)) {\n          // Restore the input value in the DOM immediately so we can synchronously update the selection position.\n          // But also update the value in React state as well so it is correct for future updates.\n          var _compositionStartStat = compositionStartState.current,\n              value = _compositionStartStat.value,\n              selectionStart = _compositionStartStat.selectionStart,\n              selectionEnd = _compositionStartStat.selectionEnd;\n          inputRef.current.value = value;\n          inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n          state1.setInputValue(value);\n        }\n      }\n    }),\n    labelProps: labelProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  };\n}\n\nexport { $2d73ec29415bd339$export$712718f7aec83d5 as useTextField, $d841c8010a73d545$export$4f384c9210e583c3 as useFormattedTextField };","map":null,"metadata":{},"sourceType":"module"}