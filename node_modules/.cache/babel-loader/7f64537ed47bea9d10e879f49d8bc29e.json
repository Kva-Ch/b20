{"ast":null,"code":"import { useId as $13Gtr$useId, filterDOMProps as $13Gtr$filterDOMProps, mergeProps as $13Gtr$mergeProps, useSlotId as $13Gtr$useSlotId } from \"@react-aria/utils\";\nimport { useHighlightSelectionDescription as $13Gtr$useHighlightSelectionDescription, useGridSelectionAnnouncement as $13Gtr$useGridSelectionAnnouncement, useGridSelectionCheckbox as $13Gtr$useGridSelectionCheckbox } from \"@react-aria/grid\";\nimport { useSelectableList as $13Gtr$useSelectableList, useSelectableItem as $13Gtr$useSelectableItem } from \"@react-aria/selection\";\nimport { focusSafely as $13Gtr$focusSafely, getFocusableTreeWalker as $13Gtr$getFocusableTreeWalker } from \"@react-aria/focus\";\nimport { isFocusVisible as $13Gtr$isFocusVisible } from \"@react-aria/interactions\";\nimport { useLocale as $13Gtr$useLocale } from \"@react-aria/i18n\";\nconst $ce9b18daab526bbd$export$5b9bb410392e3991 = new WeakMap();\n\nfunction $ce9b18daab526bbd$export$f45c25170b9a99c2(state, key) {\n  let {\n    id: id\n  } = $ce9b18daab526bbd$export$5b9bb410392e3991.get(state);\n  if (!id) throw new Error('Unknown list');\n  return `${id}-${$ce9b18daab526bbd$export$e0c709538cb8ae18(key)}`;\n}\n\nfunction $ce9b18daab526bbd$export$e0c709538cb8ae18(key) {\n  if (typeof key === 'string') return key.replace(/\\s*/g, '');\n  return '' + key;\n}\n\nfunction $f47efb0c3a859cf2$export$664f9155035607eb(props, state, ref) {\n  let {\n    isVirtualized: isVirtualized,\n    keyboardDelegate: keyboardDelegate,\n    onAction: onAction\n  } = props;\n  if (!props['aria-label'] && !props['aria-labelledby']) console.warn('An aria-label or aria-labelledby prop is required for accessibility.');\n  let {\n    listProps: listProps\n  } = $13Gtr$useSelectableList({\n    selectionManager: state.selectionManager,\n    collection: state.collection,\n    disabledKeys: state.disabledKeys,\n    ref: ref,\n    keyboardDelegate: keyboardDelegate,\n    isVirtualized: isVirtualized,\n    selectOnFocus: state.selectionManager.selectionBehavior === 'replace'\n  });\n  let id = $13Gtr$useId();\n  $ce9b18daab526bbd$export$5b9bb410392e3991.set(state, {\n    id: id,\n    onAction: onAction\n  });\n  let descriptionProps = $13Gtr$useHighlightSelectionDescription({\n    selectionManager: state.selectionManager,\n    hasItemActions: !!onAction\n  });\n  let domProps = $13Gtr$filterDOMProps(props, {\n    labelable: true\n  });\n  let gridProps = $13Gtr$mergeProps(domProps, {\n    role: 'grid',\n    id: id,\n    'aria-multiselectable': state.selectionManager.selectionMode === 'multiple' ? 'true' : undefined\n  }, listProps, descriptionProps);\n\n  if (isVirtualized) {\n    gridProps['aria-rowcount'] = state.collection.size;\n    gridProps['aria-colcount'] = 1;\n  }\n\n  $13Gtr$useGridSelectionAnnouncement({}, state);\n  return {\n    gridProps: gridProps\n  };\n}\n\nfunction $4e8b0456ef72939f$export$9610e69494fadfd2(props, state, ref) {\n  // Copied from useGridCell + some modifications to make it not so grid specific\n  let {\n    node: node,\n    isVirtualized: isVirtualized,\n    shouldSelectOnPressUp: shouldSelectOnPressUp\n  } = props;\n  let {\n    direction: direction\n  } = $13Gtr$useLocale();\n  let {\n    onAction: onAction\n  } = $ce9b18daab526bbd$export$5b9bb410392e3991.get(state);\n  let descriptionId = $13Gtr$useSlotId();\n\n  let focus = () => {\n    // Don't shift focus to the row if the active element is a element within the row already\n    // (e.g. clicking on a row button)\n    if (!ref.current.contains(document.activeElement)) $13Gtr$focusSafely(ref.current);\n  };\n\n  let {\n    itemProps: itemProps,\n    ...itemStates\n  } = $13Gtr$useSelectableItem({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref: ref,\n    isVirtualized: isVirtualized,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onAction ? () => onAction(node.key) : undefined,\n    focus: focus\n  });\n\n  let onKeyDown = e => {\n    if (!e.currentTarget.contains(e.target)) return;\n    let walker = $13Gtr$getFocusableTreeWalker(ref.current);\n    walker.currentNode = document.activeElement;\n\n    switch (e.key) {\n      case 'ArrowLeft':\n        {\n          // Find the next focusable element within the row.\n          let focusable = direction === 'rtl' ? walker.nextNode() : walker.previousNode();\n\n          if (focusable) {\n            e.preventDefault();\n            e.stopPropagation();\n            $13Gtr$focusSafely(focusable);\n          } else {\n            // If there is no next focusable child, then return focus back to the row\n            e.preventDefault();\n            e.stopPropagation();\n            if (direction === 'rtl') $13Gtr$focusSafely(ref.current);else {\n              walker.currentNode = ref.current;\n              let lastElement = $4e8b0456ef72939f$var$last(walker);\n              if (lastElement) $13Gtr$focusSafely(lastElement);\n            }\n          }\n\n          break;\n        }\n\n      case 'ArrowRight':\n        {\n          let focusable = direction === 'rtl' ? walker.previousNode() : walker.nextNode();\n\n          if (focusable) {\n            e.preventDefault();\n            e.stopPropagation();\n            $13Gtr$focusSafely(focusable);\n          } else {\n            e.preventDefault();\n            e.stopPropagation();\n            if (direction === 'ltr') $13Gtr$focusSafely(ref.current);else {\n              walker.currentNode = ref.current;\n              let lastElement = $4e8b0456ef72939f$var$last(walker);\n              if (lastElement) $13Gtr$focusSafely(lastElement);\n            }\n          }\n\n          break;\n        }\n\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching row children, e.g. menu buttons. We want arrow keys to navigate\n        // to the row above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n        }\n\n        break;\n    }\n  };\n\n  let onFocus = e => {\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the row itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row\n      // in that case since the list should act like a single tab stop.\n      if (!$13Gtr$isFocusVisible()) state.selectionManager.setFocusedKey(node.key);\n      return;\n    }\n  };\n\n  let rowProps = $13Gtr$mergeProps(itemProps, {\n    role: 'row',\n    onKeyDownCapture: onKeyDown,\n    onFocus: onFocus,\n    'aria-label': node.textValue || undefined,\n    'aria-selected': state.selectionManager.canSelectItem(node.key) ? state.selectionManager.isSelected(node.key) : undefined,\n    'aria-disabled': state.selectionManager.isDisabled(node.key) || undefined,\n    'aria-labelledby': descriptionId && node.textValue ? `${$ce9b18daab526bbd$export$f45c25170b9a99c2(state, node.key)} ${descriptionId}` : undefined,\n    id: $ce9b18daab526bbd$export$f45c25170b9a99c2(state, node.key)\n  });\n  if (isVirtualized) rowProps['aria-rowindex'] = node.index + 1;\n  let gridCellProps = {\n    role: 'gridcell',\n    'aria-colindex': 1\n  };\n  return {\n    rowProps: rowProps,\n    gridCellProps: gridCellProps,\n    descriptionProps: {\n      id: descriptionId\n    },\n    ...itemStates\n  };\n}\n\nfunction $4e8b0456ef72939f$var$last(walker) {\n  let next;\n  let last;\n\n  do {\n    last = walker.lastChild();\n    if (last) next = last;\n  } while (last);\n\n  return next;\n}\n\nfunction $e52ffc04a4adbd52$export$e29f2573fabbf7b9(props, state) {\n  let {\n    key: key\n  } = props;\n  const {\n    checkboxProps: checkboxProps\n  } = $13Gtr$useGridSelectionCheckbox(props, state);\n  return {\n    checkboxProps: { ...checkboxProps,\n      'aria-labelledby': `${checkboxProps.id} ${$ce9b18daab526bbd$export$f45c25170b9a99c2(state, key)}`\n    }\n  };\n}\n\nexport { $f47efb0c3a859cf2$export$664f9155035607eb as useGridList, $4e8b0456ef72939f$export$9610e69494fadfd2 as useGridListItem, $e52ffc04a4adbd52$export$e29f2573fabbf7b9 as useGridListSelectionCheckbox };","map":{"version":3,"mappings":"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","names":["$ce9b18daab526bbd$export$5b9bb410392e3991","WeakMap","$ce9b18daab526bbd$export$f45c25170b9a99c2","state","key","id","get","Error","$ce9b18daab526bbd$export$e0c709538cb8ae18","replace","$f47efb0c3a859cf2$export$664f9155035607eb","props","ref","isVirtualized","keyboardDelegate","onAction","console","warn","listProps","$13Gtr$useSelectableList","selectionManager","collection","disabledKeys","selectOnFocus","selectionBehavior","$13Gtr$useId","set","descriptionProps","$13Gtr$useHighlightSelectionDescription","hasItemActions","domProps","$13Gtr$filterDOMProps","labelable","gridProps","$13Gtr$mergeProps","role","selectionMode","undefined","size","$13Gtr$useGridSelectionAnnouncement","$4e8b0456ef72939f$export$9610e69494fadfd2","node","shouldSelectOnPressUp","direction","$13Gtr$useLocale","descriptionId","$13Gtr$useSlotId","focus","current","contains","document","activeElement","$13Gtr$focusSafely","itemProps","itemStates","$13Gtr$useSelectableItem","onKeyDown","e","currentTarget","target","walker","$13Gtr$getFocusableTreeWalker","currentNode","focusable","nextNode","previousNode","preventDefault","stopPropagation","lastElement","$4e8b0456ef72939f$var$last","altKey","parentElement","dispatchEvent","KeyboardEvent","nativeEvent","type","onFocus","$13Gtr$isFocusVisible","setFocusedKey","rowProps","onKeyDownCapture","textValue","canSelectItem","isSelected","isDisabled","index","gridCellProps","next","last","lastChild","$e52ffc04a4adbd52$export$e29f2573fabbf7b9","checkboxProps","$13Gtr$useGridSelectionCheckbox"],"sources":["/Users/k.chaganti/Desktop/b20/b20/node_modules/@react-aria/gridlist/dist/packages/@react-aria/gridlist/src/utils.ts","/Users/k.chaganti/Desktop/b20/b20/node_modules/@react-aria/gridlist/dist/packages/@react-aria/gridlist/src/useGridList.ts","/Users/k.chaganti/Desktop/b20/b20/node_modules/@react-aria/gridlist/dist/packages/@react-aria/gridlist/src/useGridListItem.ts","/Users/k.chaganti/Desktop/b20/b20/node_modules/@react-aria/gridlist/dist/packages/@react-aria/gridlist/src/useGridListSelectionCheckbox.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport type {ListState} from '@react-stately/list';\n\ninterface ListMapShared {\n  id: string,\n  onAction: (key: Key) => void\n}\n\n// Used to share:\n// id of the list and onAction between useList, useListItem, and useListSelectionCheckbox\nexport const listMap = new WeakMap<ListState<unknown>, ListMapShared>();\n\nexport function getRowId<T>(state: ListState<T>, key: Key) {\n  let {id} = listMap.get(state);\n  if (!id) {\n    throw new Error('Unknown list');\n  }\n\n  return `${id}-${normalizeKey(key)}`;\n}\n\nexport function normalizeKey(key: Key): string {\n  if (typeof key === 'string') {\n    return key.replace(/\\s*/g, '');\n  }\n\n  return '' + key;\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaGridListProps} from '@react-types/list';\nimport {DOMAttributes, KeyboardDelegate} from '@react-types/shared';\nimport {filterDOMProps, mergeProps, useId} from '@react-aria/utils';\nimport {listMap} from './utils';\nimport {ListState} from '@react-stately/list';\nimport {RefObject} from 'react';\nimport {useGridSelectionAnnouncement, useHighlightSelectionDescription} from '@react-aria/grid';\nimport {useSelectableList} from '@react-aria/selection';\n\nexport interface AriaGridListOptions<T> extends Omit<AriaGridListProps<T>, 'children'> {\n  /** Whether the list uses virtual scrolling. */\n  isVirtualized?: boolean,\n  /**\n   * An optional keyboard delegate implementation for type to select,\n   * to override the default.\n   */\n  keyboardDelegate?: KeyboardDelegate\n}\n\nexport interface GridListAria {\n  /** Props for the grid element. */\n  gridProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a list component with interactive children.\n * A grid list displays data in a single column and enables a user to navigate its contents via directional navigation keys.\n * @param props - Props for the list.\n * @param state - State for the list, as returned by `useListState`.\n * @param ref - The ref attached to the list element.\n */\nexport function useGridList<T>(props: AriaGridListOptions<T>, state: ListState<T>, ref: RefObject<HTMLElement>): GridListAria {\n  let {\n    isVirtualized,\n    keyboardDelegate,\n    onAction\n  } = props;\n\n  if (!props['aria-label'] && !props['aria-labelledby']) {\n    console.warn('An aria-label or aria-labelledby prop is required for accessibility.');\n  }\n\n  let {listProps} = useSelectableList({\n    selectionManager: state.selectionManager,\n    collection: state.collection,\n    disabledKeys: state.disabledKeys,\n    ref,\n    keyboardDelegate: keyboardDelegate,\n    isVirtualized,\n    selectOnFocus: state.selectionManager.selectionBehavior === 'replace'\n  });\n\n  let id = useId();\n  listMap.set(state, {id, onAction});\n\n  let descriptionProps = useHighlightSelectionDescription({\n    selectionManager: state.selectionManager,\n    hasItemActions: !!onAction\n  });\n\n  let domProps = filterDOMProps(props, {labelable: true});\n  let gridProps: DOMAttributes = mergeProps(\n    domProps,\n    {\n      role: 'grid',\n      id,\n      'aria-multiselectable': state.selectionManager.selectionMode === 'multiple' ? 'true' : undefined\n    },\n    listProps,\n    descriptionProps\n  );\n\n  if (isVirtualized) {\n    gridProps['aria-rowcount'] = state.collection.size;\n    gridProps['aria-colcount'] = 1;\n  }\n\n  useGridSelectionAnnouncement({}, state);\n\n  return {\n    gridProps\n  };\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DOMAttributes, FocusableElement, Node as RSNode} from '@react-types/shared';\nimport {focusSafely, getFocusableTreeWalker} from '@react-aria/focus';\nimport {getRowId, listMap} from './utils';\nimport {isFocusVisible} from '@react-aria/interactions';\nimport type {ListState} from '@react-stately/list';\nimport {mergeProps, useSlotId} from '@react-aria/utils';\nimport {KeyboardEvent as ReactKeyboardEvent, RefObject} from 'react';\nimport {SelectableItemStates, useSelectableItem} from '@react-aria/selection';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface AriaGridListItemOptions {\n  /** An object representing the list item. Contains all the relevant information that makes up the list row. */\n  node: RSNode<unknown>,\n  /** Whether the list row is contained in a virtual scroller. */\n  isVirtualized?: boolean,\n  /** Whether selection should occur on press up instead of press down. */\n  shouldSelectOnPressUp?: boolean\n}\n\nexport interface GridListItemAria extends SelectableItemStates {\n  /** Props for the list row element. */\n  rowProps: DOMAttributes,\n  /** Props for the grid cell element within the list row. */\n  gridCellProps: DOMAttributes,\n  /** Props for the list item description element, if any. */\n  descriptionProps: DOMAttributes\n}\n\n/**\n * Provides the behavior and accessibility implementation for a row in a grid list.\n * @param props - Props for the row.\n * @param state - State of the parent list, as returned by `useListState`.\n * @param ref - The ref attached to the row element.\n */\nexport function useGridListItem<T>(props: AriaGridListItemOptions, state: ListState<T>, ref: RefObject<FocusableElement>): GridListItemAria {\n  // Copied from useGridCell + some modifications to make it not so grid specific\n  let {\n    node,\n    isVirtualized,\n    shouldSelectOnPressUp\n  } = props;\n\n  let {direction} = useLocale();\n  let {onAction} = listMap.get(state);\n  let descriptionId = useSlotId();\n  let focus = () => {\n    // Don't shift focus to the row if the active element is a element within the row already\n    // (e.g. clicking on a row button)\n    if (!ref.current.contains(document.activeElement)) {\n      focusSafely(ref.current);\n    }\n  };\n\n  let {itemProps, ...itemStates} = useSelectableItem({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref,\n    isVirtualized,\n    shouldSelectOnPressUp,\n    onAction: onAction ? () => onAction(node.key) : undefined,\n    focus\n  });\n\n  let onKeyDown = (e: ReactKeyboardEvent) => {\n    if (!e.currentTarget.contains(e.target as Element)) {\n      return;\n    }\n\n    let walker = getFocusableTreeWalker(ref.current);\n    walker.currentNode = document.activeElement;\n\n    switch (e.key) {\n      case 'ArrowLeft': {\n        // Find the next focusable element within the row.\n        let focusable = direction === 'rtl'\n          ? walker.nextNode() as FocusableElement\n          : walker.previousNode() as FocusableElement;\n\n        if (focusable) {\n          e.preventDefault();\n          e.stopPropagation();\n          focusSafely(focusable);\n        } else {\n          // If there is no next focusable child, then return focus back to the row\n          e.preventDefault();\n          e.stopPropagation();\n          if (direction === 'rtl') {\n            focusSafely(ref.current);\n          } else {\n            walker.currentNode = ref.current;\n            let lastElement = last(walker);\n            if (lastElement) {\n              focusSafely(lastElement);\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        let focusable = direction === 'rtl'\n          ? walker.previousNode() as FocusableElement\n          : walker.nextNode() as FocusableElement;\n\n        if (focusable) {\n          e.preventDefault();\n          e.stopPropagation();\n          focusSafely(focusable);\n        } else {\n          e.preventDefault();\n          e.stopPropagation();\n          if (direction === 'ltr') {\n            focusSafely(ref.current);\n          } else {\n            walker.currentNode = ref.current;\n            let lastElement = last(walker);\n            if (lastElement) {\n              focusSafely(lastElement);\n            }\n          }\n        }\n        break;\n      }\n      case 'ArrowUp':\n      case 'ArrowDown':\n        // Prevent this event from reaching row children, e.g. menu buttons. We want arrow keys to navigate\n        // to the row above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target as Element)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement.dispatchEvent(\n            new KeyboardEvent(e.nativeEvent.type, e.nativeEvent)\n          );\n        }\n        break;\n    }\n  };\n\n  let onFocus = (e) => {\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the row itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row\n      // in that case since the list should act like a single tab stop.\n      if (!isFocusVisible()) {\n        state.selectionManager.setFocusedKey(node.key);\n      }\n      return;\n    }\n  };\n\n  let rowProps: DOMAttributes = mergeProps(itemProps, {\n    role: 'row',\n    onKeyDownCapture: onKeyDown,\n    onFocus,\n    'aria-label': node.textValue || undefined,\n    'aria-selected': state.selectionManager.canSelectItem(node.key) ? state.selectionManager.isSelected(node.key) : undefined,\n    'aria-disabled': state.selectionManager.isDisabled(node.key) || undefined,\n    'aria-labelledby': descriptionId && node.textValue ? `${getRowId(state, node.key)} ${descriptionId}` : undefined,\n    id: getRowId(state, node.key)\n  });\n\n  if (isVirtualized) {\n    rowProps['aria-rowindex'] = node.index + 1;\n  }\n\n  let gridCellProps = {\n    role: 'gridcell',\n    'aria-colindex': 1\n  };\n\n  return {\n    rowProps,\n    gridCellProps,\n    descriptionProps: {\n      id: descriptionId\n    },\n    ...itemStates\n  };\n}\n\nfunction last(walker: TreeWalker) {\n  let next: FocusableElement;\n  let last: FocusableElement;\n  do {\n    last = walker.lastChild() as FocusableElement;\n    if (last) {\n      next = last;\n    }\n  } while (last);\n  return next;\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaGridSelectionCheckboxProps, GridSelectionCheckboxAria, useGridSelectionCheckbox} from '@react-aria/grid';\nimport {getRowId} from './utils';\nimport type {ListState} from '@react-stately/list';\n\n/**\n * Provides the behavior and accessibility implementation for a selection checkbox in a grid list.\n * @param props - Props for the selection checkbox.\n * @param state - State of the list, as returned by `useListState`.\n */\nexport function useGridListSelectionCheckbox<T>(props: AriaGridSelectionCheckboxProps, state: ListState<T>): GridSelectionCheckboxAria {\n  let {key} = props;\n  const {checkboxProps} = useGridSelectionCheckbox(props, state as any);\n\n  return {\n    checkboxProps: {\n      ...checkboxProps,\n      'aria-labelledby': `${checkboxProps.id} ${getRowId(state, key)}`\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}