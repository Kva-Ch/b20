{"ast":null,"code":"import _slicedToArray from \"/Users/s.gollapalli/Desktop/project/b20-master-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectSpread from \"/Users/s.gollapalli/Desktop/project/b20-master-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"/Users/s.gollapalli/Desktop/project/b20-master-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/s.gollapalli/Desktop/project/b20-master-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark($fc36f9a046a9ce79$export$cfc14088dfefce5f);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { useState as $8D3nr$useState, useMemo as $8D3nr$useMemo, useEffect as $8D3nr$useEffect, useCallback as $8D3nr$useCallback } from \"react\";\nimport { useLayoutEffect as $8D3nr$useLayoutEffect } from \"@react-aria/utils\";\n\nvar $c74cda7d31af1253$export$c84671f46d6a1ca = /*#__PURE__*/function () {\n  function $c74cda7d31af1253$export$c84671f46d6a1ca() {\n    _classCallCheck(this, $c74cda7d31af1253$export$c84671f46d6a1ca);\n  }\n\n  _createClass($c74cda7d31af1253$export$c84671f46d6a1ca, [{\n    key: \"shouldInvalidate\",\n\n    /**\n    * Returns whether the layout should invalidate in response to\n    * visible rectangle changes. By default, it only invalidates\n    * when the collection view's size changes. Return true always\n    * to make the layout invalidate while scrolling (e.g. sticky headers).\n    */\n    value: function shouldInvalidate(newRect, oldRect) {\n      // By default, invalidate when the size changes\n      return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n    }\n    /**\n    * This method allows the layout to perform any pre-computation\n    * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n    * Called by the collection view before {@link getVisibleLayoutInfos}\n    * or {@link getLayoutInfo} are called.\n    */\n\n  }, {\n    key: \"validate\",\n    value: function validate(invalidationContext) {}\n    /**\n    * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n    * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n    * @param point The point at which the drag occurred.\n    */\n    // getDragTarget(point: Point): DragTarget | null {\n    //   let target = this.virtualizer.keyAtPoint(point);\n    //   if (!target) {\n    //     return null;\n    //   }\n    //   return {\n    //     type: 'item',\n    //     key: target\n    //   };\n    // }\n\n    /**\n    * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n    * to reject the drop. The dropped items will be inserted before the resulting target.\n    * @param point The point at which the drop occurred.\n    */\n    // getDropTarget(point: Point): DropTarget | null {\n    //   return null;\n    // }\n\n    /**\n    * Returns the starting attributes for an animated insertion.\n    * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n    * The default implementation just returns its input.\n    *\n    * @param layoutInfo The proposed LayoutInfo for this view.\n    */\n\n  }, {\n    key: \"getInitialLayoutInfo\",\n    value: function getInitialLayoutInfo(layoutInfo) {\n      return layoutInfo;\n    }\n    /**\n    * Returns the ending attributes for an animated removal.\n    * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n    * to the one returned by this method. The default implementation returns its input.\n    *\n    * @param layoutInfo The original LayoutInfo for this view.\n    */\n\n  }, {\n    key: \"getFinalLayoutInfo\",\n    value: function getFinalLayoutInfo(layoutInfo) {\n      return layoutInfo;\n    }\n  }]);\n\n  return $c74cda7d31af1253$export$c84671f46d6a1ca;\n}();\n\nvar $d7fd61009c21d0bb$export$7e0eeb9da702a085 = /*#__PURE__*/function () {\n  _createClass($d7fd61009c21d0bb$export$7e0eeb9da702a085, [{\n    key: \"copy\",\n\n    /**\n    * Returns a copy of the LayoutInfo.\n    */\n    value: function copy() {\n      var res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n      res.estimatedSize = this.estimatedSize;\n      res.opacity = this.opacity;\n      res.transform = this.transform;\n      res.parentKey = this.parentKey;\n      res.isSticky = this.isSticky;\n      res.zIndex = this.zIndex;\n      res.allowOverflow = this.allowOverflow;\n      return res;\n    }\n    /**\n    * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n    * @param key The unique key for this view.\n    * @param rect The rectangle describing the size and position of this view.\n    */\n\n  }]);\n\n  function $d7fd61009c21d0bb$export$7e0eeb9da702a085(type, key, rect) {\n    _classCallCheck(this, $d7fd61009c21d0bb$export$7e0eeb9da702a085);\n\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n    this.allowOverflow = false;\n  }\n\n  return $d7fd61009c21d0bb$export$7e0eeb9da702a085;\n}();\n\nvar $3041db3296945e6e$export$baf26146a414f24a = /*#__PURE__*/function () {\n  _createClass($3041db3296945e6e$export$baf26146a414f24a, [{\n    key: \"copy\",\n\n    /**\n    * Returns a copy of this point.\n    */\n    value: function copy() {\n      return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n    * Checks if two points are equal.\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(point) {\n      return this.x === point.x && this.y === point.y;\n    }\n    /**\n    * Returns true if this point is the origin.\n    */\n\n  }, {\n    key: \"isOrigin\",\n    value: function isOrigin() {\n      return this.x === 0 && this.y === 0;\n    }\n  }]);\n\n  function $3041db3296945e6e$export$baf26146a414f24a() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, $3041db3296945e6e$export$baf26146a414f24a);\n\n    this.x = x;\n    this.y = y;\n  }\n\n  return $3041db3296945e6e$export$baf26146a414f24a;\n}();\n\nvar $60423f92c7f9ad87$export$c79fc6492f3af13d = /*#__PURE__*/function () {\n  _createClass($60423f92c7f9ad87$export$c79fc6492f3af13d, [{\n    key: \"intersects\",\n\n    /**\n    * Returns whether this rectangle intersects another rectangle.\n    * @param rect - The rectangle to check.\n    */\n    value: function intersects(rect) {\n      return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n    }\n    /**\n    * Returns whether this rectangle fully contains another rectangle.\n    * @param rect - The rectangle to check.\n    */\n\n  }, {\n    key: \"containsRect\",\n    value: function containsRect(rect) {\n      return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n    }\n    /**\n    * Returns whether the rectangle contains the given point.\n    * @param point - The point to check.\n    */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n    }\n    /**\n    * Returns the first corner of this rectangle (from top to bottom, left to right)\n    * that is contained in the given rectangle, or null of the rectangles do not intersect.\n    * @param rect - The rectangle to check.\n    */\n\n  }, {\n    key: \"getCornerInRect\",\n    value: function getCornerInRect(rect) {\n      for (var _i = 0, _arr = ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']; _i < _arr.length; _i++) {\n        var key = _arr[_i];\n        if (rect.containsPoint(this[key])) return key;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rect) {\n      return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n  }, {\n    key: \"pointEquals\",\n    value: function pointEquals(point) {\n      return this.x === point.x && this.y === point.y;\n    }\n  }, {\n    key: \"sizeEquals\",\n    value: function sizeEquals(size) {\n      return this.width === size.width && this.height === size.height;\n    }\n    /**\n    * Returns a copy of this rectangle.\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n    }\n  }, {\n    key: \"maxX\",\n\n    /**\n    * The maximum x-coordinate in the rectangle.\n    */\n    get: function get() {\n      return this.x + this.width;\n    }\n    /**\n    * The maximum y-coordinate in the rectangle.\n    */\n\n  }, {\n    key: \"maxY\",\n    get: function get() {\n      return this.y + this.height;\n    }\n    /**\n    * The area of the rectangle.\n    */\n\n  }, {\n    key: \"area\",\n    get: function get() {\n      return this.width * this.height;\n    }\n    /**\n    * The top left corner of the rectangle.\n    */\n\n  }, {\n    key: \"topLeft\",\n    get: function get() {\n      return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n    * The top right corner of the rectangle.\n    */\n\n  }, {\n    key: \"topRight\",\n    get: function get() {\n      return new $3041db3296945e6e$export$baf26146a414f24a(this.maxX, this.y);\n    }\n    /**\n    * The bottom left corner of the rectangle.\n    */\n\n  }, {\n    key: \"bottomLeft\",\n    get: function get() {\n      return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.maxY);\n    }\n    /**\n    * The bottom right corner of the rectangle.\n    */\n\n  }, {\n    key: \"bottomRight\",\n    get: function get() {\n      return new $3041db3296945e6e$export$baf26146a414f24a(this.maxX, this.maxY);\n    }\n  }]);\n\n  function $60423f92c7f9ad87$export$c79fc6492f3af13d() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    _classCallCheck(this, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  return $60423f92c7f9ad87$export$c79fc6492f3af13d;\n}();\n\nvar $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec = /*#__PURE__*/function () {\n  _createClass($ee1bfa90a957fb8a$export$cb6da89c6af1a8ec, [{\n    key: \"copy\",\n\n    /**\n    * Returns a copy of this size.\n    */\n    value: function copy() {\n      return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n    }\n    /**\n    * Returns whether this size is equal to another one.\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.width === other.width && this.height === other.height;\n    }\n  }]);\n\n  function $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec() {\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n\n    this.width = width;\n    this.height = height;\n  }\n\n  return $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec;\n}();\n\nvar $ad1d98aa8f0c31b4$var$KEY = 0;\n\nvar $ad1d98aa8f0c31b4$export$1a5223887c560441 = /*#__PURE__*/function () {\n  _createClass($ad1d98aa8f0c31b4$export$1a5223887c560441, [{\n    key: \"prepareForReuse\",\n\n    /**\n    * Prepares the view for reuse. Called just before the view is removed from the DOM.\n    */\n    value: function prepareForReuse() {\n      this.content = null;\n      this.rendered = null;\n      this.layoutInfo = null;\n    }\n  }]);\n\n  function $ad1d98aa8f0c31b4$export$1a5223887c560441(virtualizer) {\n    _classCallCheck(this, $ad1d98aa8f0c31b4$export$1a5223887c560441);\n\n    this.virtualizer = virtualizer;\n    this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n  }\n\n  return $ad1d98aa8f0c31b4$export$1a5223887c560441;\n}(); // use high res timer if available\n\n\nvar $3eb131dcf37ad5f8$var$perf = typeof window !== 'undefined' ? window.performance : null; // @ts-ignore\n\nvar $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nvar $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\nvar $3eb131dcf37ad5f8$var$fixTs;\n\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n  var canceled = false;\n  var raf_id;\n  var promise = new Promise(function (resolve) {\n    var start = $3eb131dcf37ad5f8$var$getTime();\n    var diffX = end.x - begin.x;\n    var diffY = end.y - begin.y;\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1000000000000 !== $3eb131dcf37ad5f8$var$getTime() > 1000000000000;\n      if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime(); // check if we're done\n\n      var delta = t - start;\n\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        var proceed = fn(new $3041db3296945e6e$export$baf26146a414f24a(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n        if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n      }\n    });\n  });\n\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n\n  return promise;\n}\n\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n  return t;\n}\n\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n\nfunction $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n  var res = new Set();\n\n  var _iterator = _createForOfIteratorHelper(a.keys()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      if (!b.has(key)) res.add(key);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return res;\n}\n\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n  var toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n  var toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n  var toUpdate = new Set();\n\n  var _iterator2 = _createForOfIteratorHelper(a.keys()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value;\n      if (b.has(key)) toUpdate.add(key);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return {\n    toRemove: toRemove,\n    toAdd: toAdd,\n    toUpdate: toUpdate\n  };\n}\n\nfunction $fc36f9a046a9ce79$export$cfc14088dfefce5f() {\n  var _len,\n      iterators,\n      _key,\n      _i2,\n      _iterators,\n      iterator,\n      _args = arguments;\n\n  return _regeneratorRuntime().wrap(function $fc36f9a046a9ce79$export$cfc14088dfefce5f$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          for (_len = _args.length, iterators = new Array(_len), _key = 0; _key < _len; _key++) {\n            iterators[_key] = _args[_key];\n          }\n\n          _i2 = 0, _iterators = iterators;\n\n        case 2:\n          if (!(_i2 < _iterators.length)) {\n            _context.next = 8;\n            break;\n          }\n\n          iterator = _iterators[_i2];\n          return _context.delegateYield(iterator, \"t0\", 5);\n\n        case 5:\n          _i2++;\n          _context.next = 2;\n          break;\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n  var res = {};\n\n  for (var key in object) {\n    res[object[key]] = key;\n  }\n\n  return res;\n}\n\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n  if (a === b) return true;\n  if (a.size !== b.size) return false;\n\n  var _iterator3 = _createForOfIteratorHelper(a),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var key = _step3.value;\n      if (!b.has(key)) return false;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return true;\n}\n\nvar $364191b3decf3697$var$RollingAverage = /*#__PURE__*/function () {\n  _createClass($364191b3decf3697$var$RollingAverage, [{\n    key: \"addSample\",\n    value: function addSample(sample) {\n      this.count++;\n      this.value += (sample - this.value) / this.count;\n    }\n  }]);\n\n  function $364191b3decf3697$var$RollingAverage() {\n    _classCallCheck(this, $364191b3decf3697$var$RollingAverage);\n\n    this.count = 0;\n    this.value = 0;\n  }\n\n  return $364191b3decf3697$var$RollingAverage;\n}();\n\nvar $364191b3decf3697$export$4455ee6afb38dcbb = /*#__PURE__*/function () {\n  _createClass($364191b3decf3697$export$4455ee6afb38dcbb, [{\n    key: \"setVisibleRect\",\n    value: function setVisibleRect(rect) {\n      var time = performance.now() - this.startTime;\n\n      if (time < 500) {\n        this.averageTime.addSample(time);\n        if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n        if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n      }\n\n      this.startTime = performance.now();\n      this.visibleRect = rect;\n    }\n  }, {\n    key: \"collectMetrics\",\n    value: function collectMetrics() {\n      var time = performance.now() - this.startTime;\n      if (time < 500) this.averagePerf.addSample(time);\n\n      if (this.visibleRect.height > 0) {\n        var o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n        this.overscanY.addSample(o);\n      }\n\n      if (this.visibleRect.width > 0) {\n        var _o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n\n        this.overscanX.addSample(_o);\n      }\n    }\n  }, {\n    key: \"getOverscannedRect\",\n    value: function getOverscannedRect() {\n      var overscanned = this.visibleRect.copy();\n      var overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n\n      if (this.velocity.y > 0) {\n        overscanned.y -= overscanY * 0.2;\n        overscanned.height += overscanY + overscanY * 0.2;\n      } else {\n        overscanned.y -= overscanY;\n        overscanned.height += overscanY + overscanY * 0.2;\n      }\n\n      var overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n\n      if (this.velocity.x > 0) {\n        overscanned.x -= overscanX * 0.2;\n        overscanned.width += overscanX + overscanX * 0.2;\n      } else {\n        overscanned.x -= overscanX;\n        overscanned.width += overscanX + overscanX * 0.2;\n      }\n\n      return overscanned;\n    }\n  }]);\n\n  function $364191b3decf3697$export$4455ee6afb38dcbb() {\n    _classCallCheck(this, $364191b3decf3697$export$4455ee6afb38dcbb);\n\n    this.startTime = 0;\n    this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n    this.averageTime = new $364191b3decf3697$var$RollingAverage();\n    this.velocity = new $3041db3296945e6e$export$baf26146a414f24a(5, 5);\n    this.overscanX = new $364191b3decf3697$var$RollingAverage();\n    this.overscanY = new $364191b3decf3697$var$RollingAverage();\n    this.visibleRect = new $60423f92c7f9ad87$export$c79fc6492f3af13d();\n  }\n\n  return $364191b3decf3697$export$4455ee6afb38dcbb;\n}();\n\nvar $8e135e531d8dcb66$export$febc5573c75cefb0 = function $8e135e531d8dcb66$export$febc5573c75cefb0() {\n  _classCallCheck(this, $8e135e531d8dcb66$export$febc5573c75cefb0);\n\n  this.level = 0;\n  this.actions = [];\n  this.animated = true;\n  this.initialMap = new Map();\n  this.finalMap = new Map();\n  this.initialLayoutInfo = new Map();\n  this.finalLayoutInfo = new Map();\n  this.removed = new Map();\n  this.toRemove = new Map();\n};\n\nvar $38b9490c1cca8fc4$export$89be5a243e59c4b2 = /*#__PURE__*/function () {\n  _createClass($38b9490c1cca8fc4$export$89be5a243e59c4b2, [{\n    key: \"_setContentSize\",\n    value: function _setContentSize(size) {\n      this._contentSize = size;\n      this.delegate.setContentSize(size);\n    }\n  }, {\n    key: \"_setContentOffset\",\n    value: function _setContentOffset(offset) {\n      var rect = new $60423f92c7f9ad87$export$c79fc6492f3af13d(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n      this.delegate.setVisibleRect(rect);\n    }\n    /**\n    * Get the size of the scrollable content.\n    */\n\n  }, {\n    key: \"_setVisibleRect\",\n    value: function _setVisibleRect(rect) {\n      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var current = this._visibleRect; // Ignore if the rects are equal\n\n      if (rect.equals(current)) return;\n      if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n      var shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n      this._resetAnimatedContentOffset();\n\n      this._visibleRect = rect;\n      if (shouldInvalidate) this.relayout({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });else this.updateSubviews(forceUpdate);\n    }\n  }, {\n    key: \"_setData\",\n    value: function _setData(data) {\n      var _this = this;\n\n      if (data === this._collection) return;\n      if (this._collection) this._runTransaction(function () {\n        _this._collection = data;\n      }, this.transitionDuration > 0);else {\n        this._collection = data;\n        this.reloadData();\n      }\n    }\n    /**\n    * Reloads the data from the data source and relayouts the collection view.\n    * Does not animate any changes. Equivalent to re-assigning the same data source\n    * to the collection view.\n    */\n\n  }, {\n    key: \"reloadData\",\n    value: function reloadData() {\n      this.relayout({\n        contentChanged: true\n      });\n    }\n    /**\n    * Returns the item with the given key.\n    */\n\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n\n  }, {\n    key: \"isPersistedKey\",\n\n    /** Returns whether the given key, or an ancestor, is persisted. */\n    value: function isPersistedKey(key) {\n      // Quick check if the key is directly in the set of persisted keys.\n      if (this._persistedKeys.has(key)) return true; // If not, check if the key is an ancestor of any of the persisted keys.\n\n      var _iterator4 = _createForOfIteratorHelper(this._persistedKeys),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var k = _step4.value;\n\n          while (k != null) {\n            var layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return false;\n    }\n    /**\n    * Get the collection view's layout.\n    */\n\n  }, {\n    key: \"setLayout\",\n\n    /**\n    * Sets the collection view's layout, optionally with an animated transition\n    * from the current layout to the new layout.\n    * @param layout The layout to switch to.\n    * @param animated Whether to animate the layout change.\n    */\n    value: function setLayout(layout) {\n      var _this2 = this;\n\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (layout === this._layout) return;\n\n      var applyLayout = function applyLayout() {\n        if (_this2._layout) // @ts-ignore\n          _this2._layout.virtualizer = null;\n        layout.virtualizer = _this2;\n        _this2._layout = layout;\n      };\n\n      if (animated) // Animated layout transitions are really simple, thanks to our transaction support.\n        // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);else {\n        applyLayout();\n        this.relayout();\n      }\n    }\n  }, {\n    key: \"_getReuseType\",\n    value: function _getReuseType(layoutInfo, content) {\n      if (layoutInfo.type === 'item' && content) {\n        var type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n        var reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n        return {\n          type: type,\n          reuseType: reuseType\n        };\n      }\n\n      return {\n        type: layoutInfo.type,\n        reuseType: layoutInfo.type\n      };\n    }\n  }, {\n    key: \"getReusableView\",\n    value: function getReusableView(layoutInfo) {\n      var content = this.getItem(layoutInfo.key);\n\n      var _this$_getReuseType = this._getReuseType(layoutInfo, content),\n          reuseType = _this$_getReuseType.reuseType;\n\n      if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n      var reusable = this._reusableViews[reuseType];\n      var view = reusable.length > 0 ? reusable.pop() : new $ad1d98aa8f0c31b4$export$1a5223887c560441(this);\n      view.viewType = reuseType;\n\n      if (!this._animatedContentOffset.isOrigin()) {\n        layoutInfo = layoutInfo.copy();\n        layoutInfo.rect.x += this._animatedContentOffset.x;\n        layoutInfo.rect.y += this._animatedContentOffset.y;\n      }\n\n      view.layoutInfo = layoutInfo;\n\n      this._renderView(view);\n\n      return view;\n    }\n  }, {\n    key: \"_renderView\",\n    value: function _renderView(reusableView) {\n      var _reusableView$layoutI = reusableView.layoutInfo,\n          type = _reusableView$layoutI.type,\n          key = _reusableView$layoutI.key;\n      reusableView.content = this.getItem(key);\n      reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n  }, {\n    key: \"_renderContent\",\n    value: function _renderContent(type, content) {\n      var cached = this._renderedContent.get(content);\n\n      if (cached != null) return cached;\n      var rendered = this.delegate.renderView(type, content);\n      if (content) this._renderedContent.set(content, rendered);\n      return rendered;\n    }\n    /**\n    * Returns an array of all currently visible views, including both\n    * item views and supplementary views.\n    */\n\n  }, {\n    key: \"getView\",\n\n    /**\n    * Gets the visible view for the given type and key. Returns null if\n    * the view is not currently visible.\n    *\n    * @param key The key of the view to retrieve.\n    */\n    value: function getView(key) {\n      return this._visibleViews.get(key) || null;\n    }\n    /**\n    * Returns an array of visible views matching the given type.\n    * @param type The view type to find.\n    */\n\n  }, {\n    key: \"getViewsOfType\",\n    value: function getViewsOfType(type) {\n      return this.visibleViews.filter(function (v) {\n        return v.layoutInfo && v.layoutInfo.type === type;\n      });\n    }\n    /**\n    * Returns the key for the given view. Returns null\n    * if the view is not currently visible.\n    */\n\n  }, {\n    key: \"keyForView\",\n    value: function keyForView(view) {\n      if (view && view.layoutInfo) return view.layoutInfo.key;\n      return null;\n    }\n    /**\n    * Returns the key for the item view currently at the given point.\n    */\n\n  }, {\n    key: \"keyAtPoint\",\n    value: function keyAtPoint(point) {\n      var rect = new $60423f92c7f9ad87$export$c79fc6492f3af13d(point.x, point.y, 1, 1);\n      var layoutInfos = this.layout.getVisibleLayoutInfos(rect); // Layout may return multiple layout infos in the case of\n      // persisted keys, so find the first one that actually intersects.\n\n      var _iterator5 = _createForOfIteratorHelper(layoutInfos),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var layoutInfo = _step5.value;\n          if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return null;\n    }\n    /**\n    * Cleanup for when the Virtualizer will be unmounted.\n    */\n\n  }, {\n    key: \"willUnmount\",\n    value: function willUnmount() {\n      cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\n    * Triggers a layout invalidation, and updates the visible subviews.\n    */\n\n  }, {\n    key: \"relayout\",\n    value: function relayout() {\n      var _this3 = this;\n\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // Ignore relayouts while animating the scroll position\n      if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') return; // If we already scheduled a relayout, extend the invalidation\n      // context so we coalesce multiple relayouts in the same frame.\n\n      if (this._invalidationContext) {\n        Object.assign(this._invalidationContext, context);\n        return;\n      }\n\n      this._invalidationContext = context;\n      this._relayoutRaf = requestAnimationFrame(function () {\n        _this3._relayoutRaf = null;\n\n        _this3.relayoutNow();\n      });\n    }\n    /**\n    * Performs a relayout immediately. Prefer {@link relayout} over this method\n    * where possible, since it coalesces multiple layout passes in the same tick.\n    */\n\n  }, {\n    key: \"relayoutNow\",\n    value: function relayoutNow() {\n      var _this4 = this;\n\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._invalidationContext || {};\n\n      // Cancel the scheduled relayout, since we're doing it now.\n      if (this._relayoutRaf) {\n        cancelAnimationFrame(this._relayoutRaf);\n        this._relayoutRaf = null; // Update the provided context with the current invalidationContext since we are cancelling\n        // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n\n        context = _objectSpread({}, this._invalidationContext, context);\n      } // Reset the invalidation context\n\n\n      this._invalidationContext = null; // Do nothing if we don't have a layout or content, or we are\n      // in the middle of an animated scroll transition.\n\n      if (!this.layout || !this._collection || this._scrollAnimation) return;\n\n      var scrollAnchor = this._getScrollAnchor(); // Trigger the beforeLayout hook, if provided\n\n\n      if (typeof context.beforeLayout === 'function') context.beforeLayout(); // Validate the layout\n\n      this.layout.validate(context);\n\n      this._setContentSize(this.layout.getContentSize()); // Trigger the afterLayout hook, if provided\n\n\n      if (typeof context.afterLayout === 'function') context.afterLayout(); // Adjust scroll position based on scroll anchor, and constrain.\n      // If the content changed, scroll to the top.\n\n      var visibleRect = this.getVisibleRect();\n\n      var restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n\n      var contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n      var contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n      contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n      contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n      var hasLayoutUpdates = false;\n\n      if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n        // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n        // Save the difference between the current and new content offsets, and apply it to the\n        // individual content items instead. At the end of the animation, we'll reset and set the\n        // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n        // the scroll animation and the content animation.\n        if (context.animated || !this._animatedContentOffset.isOrigin()) {\n          this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n          this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n          hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        } else this._setContentOffset(new $3041db3296945e6e$export$baf26146a414f24a(contentOffsetX, contentOffsetY));\n      } else hasLayoutUpdates = this.updateSubviews(context.contentChanged); // Apply layout infos, unless this is coming from an animated transaction\n\n\n      if (!(context.transaction && context.animated)) this._applyLayoutInfos(); // Wait for animations, and apply the afterAnimation hook, if provided\n\n      if (context.animated && hasLayoutUpdates) {\n        this._enableTransitions();\n\n        var done = function done() {\n          _this4._disableTransitions(); // Reset scroll position after animations (see above comment).\n\n\n          if (!_this4._animatedContentOffset.isOrigin()) {\n            // Get the content offset to scroll to, taking _animatedContentOffset into account.\n            var _this4$getVisibleRect = _this4.getVisibleRect(),\n                x = _this4$getVisibleRect.x,\n                y = _this4$getVisibleRect.y;\n\n            _this4._resetAnimatedContentOffset();\n\n            _this4._setContentOffset(new $3041db3296945e6e$export$baf26146a414f24a(x, y));\n          }\n\n          if (typeof context.afterAnimation === 'function') context.afterAnimation();\n        }; // Sometimes the animation takes slightly longer than expected.\n\n\n        setTimeout(done, this.transitionDuration + 100);\n        return;\n      } else if (typeof context.afterAnimation === 'function') context.afterAnimation();\n    }\n    /**\n    * Corrects DOM order of visible views to match item order of collection.\n    */\n\n  }, {\n    key: \"_correctItemOrder\",\n    value: function _correctItemOrder() {\n      // Defer until after scrolling and animated transactions are complete\n      if (this._isScrolling || this._transaction) return;\n\n      var _iterator6 = _createForOfIteratorHelper(this._visibleLayoutInfos.keys()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var key = _step6.value;\n\n          var view = this._visibleViews.get(key);\n\n          this._children.delete(view);\n\n          this._children.add(view);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"_enableTransitions\",\n    value: function _enableTransitions() {\n      this.delegate.beginAnimations();\n    }\n  }, {\n    key: \"_disableTransitions\",\n    value: function _disableTransitions() {\n      this.delegate.endAnimations();\n    }\n  }, {\n    key: \"_getScrollAnchor\",\n    value: function _getScrollAnchor() {\n      if (!this.anchorScrollPosition) return null;\n      var visibleRect = this.getVisibleRect(); // Ask the delegate to provide a scroll anchor, if possible\n\n      if (this.delegate.getScrollAnchor) {\n        var key = this.delegate.getScrollAnchor(visibleRect);\n\n        if (key != null) {\n          var layoutInfo = this.layout.getLayoutInfo(key);\n          var corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n          if (corner) {\n            var _key2 = layoutInfo.key;\n            var offset = layoutInfo.rect[corner].y - visibleRect.y;\n            return {\n              key: _key2,\n              layoutInfo: layoutInfo,\n              corner: corner,\n              offset: offset\n            };\n          }\n        }\n      } // No need to anchor the scroll position if it is at the top\n\n\n      if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null; // Find a view with a visible corner that has the smallest distance to the top of the collection view\n\n      var cornerAnchor = null;\n\n      var _iterator7 = _createForOfIteratorHelper(this._visibleViews),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n              _key3 = _step7$value[0],\n              view = _step7$value[1];\n\n          var _layoutInfo = view.layoutInfo;\n\n          if (_layoutInfo && _layoutInfo.rect.area > 0) {\n            var _corner = _layoutInfo.rect.getCornerInRect(visibleRect);\n\n            if (_corner) {\n              var _offset = _layoutInfo.rect[_corner].y - visibleRect.y;\n\n              if (!cornerAnchor || _offset < cornerAnchor.offset) cornerAnchor = {\n                key: _key3,\n                layoutInfo: _layoutInfo,\n                corner: _corner,\n                offset: _offset\n              };\n            }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return cornerAnchor;\n    }\n  }, {\n    key: \"_restoreScrollAnchor\",\n    value: function _restoreScrollAnchor(scrollAnchor, context) {\n      var contentOffset = this.getVisibleRect();\n\n      if (scrollAnchor) {\n        var ref;\n        var finalAnchor = ((ref = context.transaction) === null || ref === void 0 ? void 0 : ref.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n        if (finalAnchor) {\n          var adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n          contentOffset.y += adjustment;\n        }\n      }\n\n      return contentOffset;\n    }\n  }, {\n    key: \"getVisibleRect\",\n    value: function getVisibleRect() {\n      var v = this.visibleRect;\n      var x = v.x - this._animatedContentOffset.x;\n      var y = v.y - this._animatedContentOffset.y;\n      return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, v.width, v.height);\n    }\n  }, {\n    key: \"getVisibleLayoutInfos\",\n    value: function getVisibleLayoutInfos() {\n      var rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n      this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n      return this._visibleLayoutInfos;\n    }\n  }, {\n    key: \"_getLayoutInfoMap\",\n    value: function _getLayoutInfoMap(rect) {\n      var copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n      var map = new Map();\n\n      var _iterator8 = _createForOfIteratorHelper(layoutInfos),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var layoutInfo = _step8.value;\n          if (copy) layoutInfo = layoutInfo.copy();\n          map.set(layoutInfo.key, layoutInfo);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return map;\n    }\n  }, {\n    key: \"updateSubviews\",\n    value: function updateSubviews() {\n      var _this5 = this;\n\n      var forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (!this._collection) return;\n      var visibleLayoutInfos = this.getVisibleLayoutInfos();\n      var currentlyVisible = this._visibleViews;\n      var toAdd, toRemove, toUpdate; // If this is a force update, remove and re-add all views.\n      // Otherwise, find and update the diff.\n\n      if (forceUpdate) {\n        toAdd = visibleLayoutInfos;\n        toRemove = currentlyVisible;\n        toUpdate = new Set();\n      } else {\n        var _$fc36f9a046a9ce79$ex = $fc36f9a046a9ce79$export$acaf96a27438246b(currentlyVisible, visibleLayoutInfos);\n\n        toAdd = _$fc36f9a046a9ce79$ex.toAdd;\n        toRemove = _$fc36f9a046a9ce79$ex.toRemove;\n        toUpdate = _$fc36f9a046a9ce79$ex.toUpdate;\n\n        var _iterator9 = _createForOfIteratorHelper(toUpdate),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var key = _step9.value;\n            var view = currentlyVisible.get(key);\n            if (!view || !view.layoutInfo) continue;\n            var item = this.getItem(visibleLayoutInfos.get(key).key);\n            if (view.content === item) toUpdate.delete(key);else {\n              // If the view type changes, delete and recreate the view instead of updating\n              var _this$_getReuseType2 = this._getReuseType(view.layoutInfo, item),\n                  reuseType = _this$_getReuseType2.reuseType;\n\n              if (view.viewType !== reuseType) {\n                toUpdate.delete(key);\n                toAdd.add(key);\n                toRemove.add(key);\n              }\n            }\n          } // We are done if the sets are equal\n\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n          if (this._transaction) this._applyLayoutInfos();\n          return;\n        }\n      } // Track views that should be removed. They are not removed from\n      // the DOM immediately, since we may reuse and need to re-insert\n      // them back into the DOM anyway.\n\n\n      var removed = new Set();\n\n      var _iterator10 = _createForOfIteratorHelper(toRemove.keys()),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _key4 = _step10.value;\n\n          var _view = this._visibleViews.get(_key4);\n\n          if (_view) {\n            removed.add(_view);\n\n            this._visibleViews.delete(_key4); // If we are in the middle of a transaction, wait until the end\n            // of the animations to remove the views from the DOM. Also means\n            // we can't reuse those views immediately.\n\n\n            if (this._transaction) this._transaction.toRemove.set(_key4, _view);else this.reuseView(_view);\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      var _iterator11 = _createForOfIteratorHelper(toAdd.keys()),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var key1 = _step11.value;\n          var layoutInfo = visibleLayoutInfos.get(key1);\n\n          var _view2 = void 0; // If we're in a transaction, and a layout change happens\n          // during the animations such that a view that was going\n          // to be removed is now not, we don't create a new view\n          // since the old one is still in the DOM, marked as toRemove.\n\n\n          if (this._transaction) {\n            // if transaction, get initial layout attributes for the animation\n            if (this._transaction.initialLayoutInfo.has(key1)) layoutInfo = this._transaction.initialLayoutInfo.get(key1);\n            _view2 = this._transaction.toRemove.get(key1);\n\n            if (_view2) {\n              this._transaction.toRemove.delete(key1);\n\n              this._applyLayoutInfo(_view2, layoutInfo);\n            }\n          }\n\n          if (!_view2) {\n            // Create or reuse a view for this row\n            _view2 = this.getReusableView(layoutInfo); // Add the view to the DOM if needed\n\n            if (!removed.has(_view2)) this._children.add(_view2);\n          }\n\n          this._visibleViews.set(key1, _view2);\n\n          removed.delete(_view2);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      var _iterator12 = _createForOfIteratorHelper(toUpdate),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var key2 = _step12.value;\n\n          var _view3 = currentlyVisible.get(key2);\n\n          this._renderedContent.delete(key2);\n\n          this._renderView(_view3);\n        } // Remove the remaining rows to delete from the DOM\n\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      if (!this._transaction) this.removeViews(removed);\n\n      this._correctItemOrder();\n\n      this._flushVisibleViews();\n\n      var hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n\n      if (hasLayoutUpdates) requestAnimationFrame(function () {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (_this5._transaction) requestAnimationFrame(function () {\n          return _this5._applyLayoutInfos();\n        });\n      });\n      return hasLayoutUpdates;\n    }\n  }, {\n    key: \"afterRender\",\n    value: function afterRender() {\n      if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n  }, {\n    key: \"_flushVisibleViews\",\n    value: function _flushVisibleViews() {\n      var _this6 = this;\n\n      // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n      // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n      // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n      // method to build the final tree.\n      var viewsByParentKey = new Map([[null, []]]);\n\n      var _iterator13 = _createForOfIteratorHelper(this._children),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var view1 = _step13.value;\n          if (!viewsByParentKey.has(view1.layoutInfo.parentKey)) viewsByParentKey.set(view1.layoutInfo.parentKey, []);\n          viewsByParentKey.get(view1.layoutInfo.parentKey).push(view1);\n          if (!viewsByParentKey.has(view1.layoutInfo.key)) viewsByParentKey.set(view1.layoutInfo.key, []);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      var buildTree = function buildTree(parent, views) {\n        return views.map(function (view) {\n          var children = viewsByParentKey.get(view.layoutInfo.key);\n          return _this6.delegate.renderWrapper(parent, view, children, function (childViews) {\n            return buildTree(view, childViews);\n          });\n        });\n      };\n\n      var children1 = buildTree(null, viewsByParentKey.get(null));\n      this.delegate.setVisibleViews(children1);\n    }\n  }, {\n    key: \"_applyLayoutInfo\",\n    value: function _applyLayoutInfo(view, layoutInfo) {\n      if (view.layoutInfo === layoutInfo) return false;\n      view.layoutInfo = layoutInfo;\n      return true;\n    }\n  }, {\n    key: \"_applyLayoutInfos\",\n    value: function _applyLayoutInfos() {\n      var updated = false; // Apply layout infos to visible views\n\n      var _iterator14 = _createForOfIteratorHelper(this._visibleViews.values()),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _view4 = _step14.value;\n          var _cur2 = _view4.layoutInfo;\n\n          if (_cur2) {\n            var _layoutInfo3 = this.layout.getLayoutInfo(_cur2.key);\n\n            if (this._applyLayoutInfo(_view4, _layoutInfo3)) updated = true;\n          }\n        } // Apply final layout infos for views that will be removed\n\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      if (this._transaction) {\n        var _iterator15 = _createForOfIteratorHelper(this._transaction.toRemove.values()),\n            _step15;\n\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var view = _step15.value;\n            var cur = view.layoutInfo;\n            var layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n\n        var _iterator16 = _createForOfIteratorHelper(this._transaction.removed.values()),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var view2 = _step16.value;\n            var _cur = view2.layoutInfo;\n\n            var _layoutInfo2 = this._transaction.finalLayoutInfo.get(_cur.key) || _cur;\n\n            _layoutInfo2 = this.layout.getFinalLayoutInfo(_layoutInfo2.copy());\n            if (this._applyLayoutInfo(view2, _layoutInfo2)) updated = true;\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      }\n\n      if (updated) this._flushVisibleViews();\n    }\n  }, {\n    key: \"_hasLayoutUpdates\",\n    value: function _hasLayoutUpdates() {\n      if (!this._transaction) return false;\n\n      var _iterator17 = _createForOfIteratorHelper(this._visibleViews.values()),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var view = _step17.value;\n          var cur = view.layoutInfo;\n          if (!cur) return true;\n          var layoutInfo = this.layout.getLayoutInfo(cur.key);\n          if ( // Uses equals rather than pointEquals so that width/height changes are taken into account\n          !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"reuseView\",\n    value: function reuseView(view) {\n      view.prepareForReuse();\n\n      this._reusableViews[view.viewType].push(view);\n    }\n  }, {\n    key: \"removeViews\",\n    value: function removeViews(toRemove) {\n      var _iterator18 = _createForOfIteratorHelper(toRemove),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var view = _step18.value;\n\n          this._children.delete(view);\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n    }\n  }, {\n    key: \"updateItemSize\",\n    value: function updateItemSize(key, size) {\n      // TODO: we should be able to invalidate a single index path\n      // @ts-ignore\n      if (!this.layout.updateItemSize) return; // If the scroll position is currently animating, add the update\n      // to a queue to be processed after the animation is complete.\n\n      if (this._scrollAnimation) {\n        this._sizeUpdateQueue.set(key, size);\n\n        return;\n      } // @ts-ignore\n\n\n      var changed = this.layout.updateItemSize(key, size);\n      if (changed) this.relayout();\n    }\n  }, {\n    key: \"startScrolling\",\n    value: function startScrolling() {\n      this._isScrolling = true;\n    }\n  }, {\n    key: \"endScrolling\",\n    value: function endScrolling() {\n      this._isScrolling = false;\n\n      this._correctItemOrder();\n\n      this._flushVisibleViews();\n    }\n  }, {\n    key: \"_resetAnimatedContentOffset\",\n    value: function _resetAnimatedContentOffset() {\n      // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n      if (!this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset = new $3041db3296945e6e$export$baf26146a414f24a(0, 0);\n\n        this._applyLayoutInfos();\n      }\n    }\n    /**\n    * Scrolls the item with the given key into view, optionally with an animation.\n    * @param key The key of the item to scroll into view.\n    * @param duration The duration of the scroll animation.\n    */\n\n  }, {\n    key: \"scrollToItem\",\n    value: function scrollToItem(key, options) {\n      // key can be 0, so check if null or undefined\n      if (key == null) return;\n      var layoutInfo = this.layout.getLayoutInfo(key);\n      if (!layoutInfo) return;\n      var _options$duration = options.duration,\n          duration = _options$duration === void 0 ? 300 : _options$duration,\n          _options$shouldScroll = options.shouldScrollX,\n          shouldScrollX = _options$shouldScroll === void 0 ? true : _options$shouldScroll,\n          _options$shouldScroll2 = options.shouldScrollY,\n          shouldScrollY = _options$shouldScroll2 === void 0 ? true : _options$shouldScroll2,\n          _options$offsetX = options.offsetX,\n          offsetX = _options$offsetX === void 0 ? 0 : _options$offsetX,\n          _options$offsetY = options.offsetY,\n          offsetY = _options$offsetY === void 0 ? 0 : _options$offsetY;\n      var x = this.visibleRect.x;\n      var y = this.visibleRect.y;\n      var minX = layoutInfo.rect.x - offsetX;\n      var minY = layoutInfo.rect.y - offsetY;\n      var maxX = x + this.visibleRect.width;\n      var maxY = y + this.visibleRect.height;\n\n      if (shouldScrollX) {\n        if (minX <= x || maxX === 0) x = minX;else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n      }\n\n      if (shouldScrollY) {\n        if (minY <= y || maxY === 0) y = minY;else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n      }\n\n      return this.scrollTo(new $3041db3296945e6e$export$baf26146a414f24a(x, y), duration);\n    }\n    /**\n    * Performs an animated scroll to the given offset.\n    * @param offset - The offset to scroll to.\n    * @param duration The duration of the animation.\n    * @returns A promise that resolves when the animation is complete.\n    */\n\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(offset1) {\n      var _this7 = this;\n\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n\n      // Cancel the current scroll animation\n      if (this._scrollAnimation) {\n        this._scrollAnimation.cancel();\n\n        this._scrollAnimation = null;\n      } // Set the content offset synchronously if the duration is zero\n\n\n      if (duration <= 0 || this.visibleRect.pointEquals(offset1)) {\n        this._setContentOffset(offset1);\n\n        return Promise.resolve();\n      }\n\n      this.startScrolling();\n      this._scrollAnimation = $3eb131dcf37ad5f8$export$dc0b63720788090c(this.visibleRect, offset1, duration, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0, function (offset) {\n        _this7._setContentOffset(offset);\n      });\n\n      this._scrollAnimation.then(function () {\n        _this7._scrollAnimation = null; // Process view size updates that occurred during the animation.\n        // Only views that are still visible will be actually updated.\n\n        var _iterator19 = _createForOfIteratorHelper(_this7._sizeUpdateQueue),\n            _step19;\n\n        try {\n          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n            var _step19$value = _slicedToArray(_step19.value, 2),\n                key = _step19$value[0],\n                size = _step19$value[1];\n\n            _this7.updateItemSize(key, size);\n          }\n        } catch (err) {\n          _iterator19.e(err);\n        } finally {\n          _iterator19.f();\n        }\n\n        _this7._sizeUpdateQueue.clear();\n\n        _this7.relayout();\n\n        _this7._processTransactionQueue();\n\n        _this7.endScrolling();\n      });\n\n      return this._scrollAnimation;\n    }\n  }, {\n    key: \"_runTransaction\",\n    value: function _runTransaction(action, animated) {\n      this._startTransaction();\n\n      if (this._nextTransaction) this._nextTransaction.actions.push(action);\n\n      this._endTransaction(animated);\n    }\n  }, {\n    key: \"_startTransaction\",\n    value: function _startTransaction() {\n      if (!this._nextTransaction) this._nextTransaction = new $8e135e531d8dcb66$export$febc5573c75cefb0();\n      this._nextTransaction.level++;\n    }\n  }, {\n    key: \"_endTransaction\",\n    value: function _endTransaction(animated) {\n      if (!this._nextTransaction) return false; // Save whether the transaction should be animated.\n\n      if (animated != null) this._nextTransaction.animated = animated; // If we haven't reached level 0, we are still in a\n      // nested transaction. Wait for the parent to end.\n\n      if (--this._nextTransaction.level > 0) return false; // Do nothing for empty transactions\n\n      if (this._nextTransaction.actions.length === 0) {\n        this._nextTransaction = null;\n        return false;\n      } // Default animations to true\n\n\n      if (this._nextTransaction.animated == null) this._nextTransaction.animated = true; // Enqueue the transaction\n\n      this._transactionQueue.push(this._nextTransaction);\n\n      this._nextTransaction = null;\n\n      this._processTransactionQueue();\n\n      return true;\n    }\n  }, {\n    key: \"_processTransactionQueue\",\n    value: function _processTransactionQueue() {\n      // If the current transaction is animating, wait until the end\n      // to process the next transaction.\n      if (this._transaction || this._scrollAnimation) return;\n\n      var next = this._transactionQueue.shift();\n\n      if (next) this._performTransaction(next);\n    }\n  }, {\n    key: \"_getContentRect\",\n    value: function _getContentRect() {\n      return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n  }, {\n    key: \"_performTransaction\",\n    value: function _performTransaction(transaction) {\n      var _this8 = this;\n\n      this._transaction = transaction;\n      this.relayoutNow({\n        transaction: transaction,\n        animated: transaction.animated,\n        beforeLayout: function beforeLayout() {\n          // Get the initial layout infos for all views before the updates\n          // so we can figure out which views to add and remove.\n          if (transaction.animated) transaction.initialMap = _this8._getLayoutInfoMap(_this8._getContentRect(), true); // Apply the actions that occurred during this transaction\n\n          var _iterator20 = _createForOfIteratorHelper(transaction.actions),\n              _step20;\n\n          try {\n            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n              var action = _step20.value;\n              action();\n            }\n          } catch (err) {\n            _iterator20.e(err);\n          } finally {\n            _iterator20.f();\n          }\n        },\n        afterLayout: function afterLayout() {\n          // Get the final layout infos after the updates\n          if (transaction.animated) {\n            transaction.finalMap = _this8._getLayoutInfoMap(_this8._getContentRect());\n\n            _this8._setupTransactionAnimations(transaction);\n          } else _this8._transaction = null;\n        },\n        afterAnimation: function afterAnimation() {\n          // Remove and reuse views when animations are done\n          if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n            var _iterator21 = _createForOfIteratorHelper($fc36f9a046a9ce79$export$cfc14088dfefce5f(transaction.toRemove.values(), transaction.removed.values())),\n                _step21;\n\n            try {\n              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                var view = _step21.value;\n\n                _this8._children.delete(view);\n\n                _this8.reuseView(view);\n              }\n            } catch (err) {\n              _iterator21.e(err);\n            } finally {\n              _iterator21.f();\n            }\n          }\n\n          _this8._transaction = null; // Ensure DOM order is correct for accessibility after animations are complete\n\n          _this8._correctItemOrder();\n\n          _this8._flushVisibleViews();\n\n          _this8._processTransactionQueue();\n        }\n      });\n    }\n  }, {\n    key: \"_setupTransactionAnimations\",\n    value: function _setupTransactionAnimations(transaction) {\n      var initialMap = transaction.initialMap,\n          finalMap = transaction.finalMap; // Store initial and final layout infos for animations\n\n      var _iterator22 = _createForOfIteratorHelper(initialMap),\n          _step22;\n\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var _step22$value = _slicedToArray(_step22.value, 2),\n              key = _step22$value[0],\n              layoutInfo = _step22$value[1];\n\n          if (finalMap.has(key)) // Store the initial layout info for use during animations.\n            transaction.initialLayoutInfo.set(key, layoutInfo);else // This view was removed. Store the layout info for use\n            // in Layout#getFinalLayoutInfo during animations.\n            transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        } // Get initial layout infos for views that were added\n\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n\n      var _iterator23 = _createForOfIteratorHelper(finalMap),\n          _step23;\n\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          var _step23$value = _slicedToArray(_step23.value, 2),\n              key3 = _step23$value[0],\n              layoutInfo1 = _step23$value[1];\n\n          if (!initialMap.has(key3)) {\n            var initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo1.copy());\n            transaction.initialLayoutInfo.set(key3, initialLayoutInfo);\n          }\n        } // Figure out which views were removed.\n\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n\n      var _iterator24 = _createForOfIteratorHelper(this._visibleViews),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n        // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        {\n          var _step24$value = _slicedToArray(_step24.value, 2),\n              key4 = _step24$value[0],\n              view = _step24$value[1];\n\n          if (!finalMap.has(key4) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key4, view);\n\n            this._visibleViews.delete(key4); // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n\n\n            if (view.layoutInfo) {\n              if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n    }\n  }, {\n    key: \"contentSize\",\n    get: function get() {\n      return this._contentSize;\n    }\n    /**\n    * Get the collection view's currently visible rectangle.\n    */\n\n  }, {\n    key: \"visibleRect\",\n    get: function get() {\n      return this._visibleRect;\n    }\n    /**\n    * Set the collection view's currently visible rectangle.\n    */\n    ,\n    set: function set(rect) {\n      this._setVisibleRect(rect);\n    }\n  }, {\n    key: \"collection\",\n    get: function get() {\n      return this._collection;\n    },\n    set: function set(data) {\n      this._setData(data);\n    }\n  }, {\n    key: \"persistedKeys\",\n    get: function get() {\n      return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n    ,\n    set: function set(persistedKeys) {\n      if (!$fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(persistedKeys, this._persistedKeys)) {\n        this._persistedKeys = persistedKeys;\n        this.updateSubviews();\n      }\n    }\n  }, {\n    key: \"layout\",\n    get: function get() {\n      return this._layout;\n    }\n    /**\n    * Set the collection view's layout.\n    */\n    ,\n    set: function set(layout) {\n      this.setLayout(layout);\n    }\n  }, {\n    key: \"visibleViews\",\n    get: function get() {\n      return Array.from(this._visibleViews.values());\n    }\n  }]);\n\n  function $38b9490c1cca8fc4$export$89be5a243e59c4b2() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, $38b9490c1cca8fc4$export$89be5a243e59c4b2);\n\n    this._contentSize = new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec();\n    this._visibleRect = new $60423f92c7f9ad87$export$c79fc6492f3af13d();\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new $364191b3decf3697$export$4455ee6afb38dcbb();\n    this._persistedKeys = new Set();\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new $3041db3296945e6e$export$baf26146a414f24a(0, 0);\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    var _transitionDuration; // Set options from passed object if given\n\n\n    this.transitionDuration = (_transitionDuration = options.transitionDuration) !== null && _transitionDuration !== void 0 ? _transitionDuration : 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n\n    for (var _i3 = 0, _arr2 = ['delegate', 'size', 'layout', 'collection']; _i3 < _arr2.length; _i3++) {\n      var key = _arr2[_i3];\n      if (options[key]) this[key] = options[key];\n    }\n  }\n\n  return $38b9490c1cca8fc4$export$89be5a243e59c4b2;\n}();\n\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n  var _$8D3nr$useState = $8D3nr$useState([]),\n      _$8D3nr$useState2 = _slicedToArray(_$8D3nr$useState, 2),\n      visibleViews = _$8D3nr$useState2[0],\n      setVisibleViews = _$8D3nr$useState2[1];\n\n  var _$8D3nr$useState3 = $8D3nr$useState(new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec()),\n      _$8D3nr$useState4 = _slicedToArray(_$8D3nr$useState3, 2),\n      contentSize = _$8D3nr$useState4[0],\n      setContentSize = _$8D3nr$useState4[1];\n\n  var _$8D3nr$useState5 = $8D3nr$useState(false),\n      _$8D3nr$useState6 = _slicedToArray(_$8D3nr$useState5, 2),\n      isAnimating = _$8D3nr$useState6[0],\n      setAnimating = _$8D3nr$useState6[1];\n\n  var _$8D3nr$useState7 = $8D3nr$useState(false),\n      _$8D3nr$useState8 = _slicedToArray(_$8D3nr$useState7, 2),\n      isScrolling = _$8D3nr$useState8[0],\n      setScrolling = _$8D3nr$useState8[1];\n\n  var virtualizer = $8D3nr$useMemo(function () {\n    return new $38b9490c1cca8fc4$export$89be5a243e59c4b2();\n  }, []);\n  virtualizer.delegate = {\n    setVisibleViews: setVisibleViews,\n    setVisibleRect: function setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n    setContentSize: setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: function beginAnimations() {\n      return setAnimating(true);\n    },\n    endAnimations: function endAnimations() {\n      return setAnimating(false);\n    },\n    getScrollAnchor: opts.getScrollAnchor\n  };\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n  $8D3nr$useLayoutEffect(function () {\n    virtualizer.afterRender();\n  }); // eslint-disable-next-line arrow-body-style\n\n  $8D3nr$useEffect(function () {\n    return function () {\n      return virtualizer.willUnmount();\n    };\n  }, []);\n  return {\n    virtualizer: virtualizer,\n    visibleViews: visibleViews,\n    setVisibleRect: $8D3nr$useCallback(function (rect) {\n      virtualizer.visibleRect = rect;\n    }, [virtualizer]),\n    contentSize: contentSize,\n    isAnimating: isAnimating,\n    isScrolling: isScrolling,\n    startScrolling: $8D3nr$useCallback(function () {\n      virtualizer.startScrolling();\n      setScrolling(true);\n    }, [virtualizer]),\n    endScrolling: $8D3nr$useCallback(function () {\n      virtualizer.endScrolling();\n      setScrolling(false);\n    }, [virtualizer])\n  };\n}\n\nexport { $c74cda7d31af1253$export$c84671f46d6a1ca as Layout, $d7fd61009c21d0bb$export$7e0eeb9da702a085 as LayoutInfo, $3041db3296945e6e$export$baf26146a414f24a as Point, $60423f92c7f9ad87$export$c79fc6492f3af13d as Rect, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec as Size, $ad1d98aa8f0c31b4$export$1a5223887c560441 as ReusableView, $fc0b13b484ac1194$export$1505db82fe357e65 as useVirtualizerState };","map":null,"metadata":{},"sourceType":"module"}