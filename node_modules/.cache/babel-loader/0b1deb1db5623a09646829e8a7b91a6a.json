{"ast":null,"code":"import _toConsumableArray from \"/Users/s.gollapalli/Desktop/project/b20-master-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/Users/s.gollapalli/Desktop/project/b20-master-2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport { filterDOMProps as $thkiX$filterDOMProps, mergeProps as $thkiX$mergeProps, useId as $thkiX$useId, chain as $thkiX$chain } from \"@react-aria/utils\";\nimport $thkiX$react, { useMemo as $thkiX$useMemo } from \"react\";\nimport { ListKeyboardDelegate as $thkiX$ListKeyboardDelegate, useTypeSelect as $thkiX$useTypeSelect } from \"@react-aria/selection\";\nimport { setInteractionModality as $thkiX$setInteractionModality, useInteractionModality as $thkiX$useInteractionModality } from \"@react-aria/interactions\";\nimport { useCollator as $thkiX$useCollator } from \"@react-aria/i18n\";\nimport { useField as $thkiX$useField } from \"@react-aria/label\";\nimport { useMenuTrigger as $thkiX$useMenuTrigger } from \"@react-aria/menu\";\nimport { useVisuallyHidden as $thkiX$useVisuallyHidden } from \"@react-aria/visually-hidden\";\n\nfunction $58aed456727eb0f3$export$e64b2f635402ca43(props, state, ref) {\n  var keyboardDelegate = props.keyboardDelegate,\n      isDisabled = props.isDisabled; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).\n  // When virtualized, the layout object will be passed in as a prop and override this.\n\n  var collator = $thkiX$useCollator({\n    usage: 'search',\n    sensitivity: 'base'\n  });\n  var delegate = $thkiX$useMemo(function () {\n    return keyboardDelegate || new $thkiX$ListKeyboardDelegate(state.collection, state.disabledKeys, null, collator);\n  }, [keyboardDelegate, state.collection, state.disabledKeys, collator]);\n\n  var _$thkiX$useMenuTrigge = $thkiX$useMenuTrigger({\n    isDisabled: isDisabled,\n    type: 'listbox'\n  }, state, ref),\n      menuTriggerProps = _$thkiX$useMenuTrigge.menuTriggerProps,\n      menuProps = _$thkiX$useMenuTrigge.menuProps;\n\n  var onKeyDown = function onKeyDown(e) {\n    switch (e.key) {\n      case 'ArrowLeft':\n        {\n          // prevent scrolling containers\n          e.preventDefault();\n          var key = state.selectedKey != null ? delegate.getKeyAbove(state.selectedKey) : delegate.getFirstKey();\n          if (key) state.setSelectedKey(key);\n          break;\n        }\n\n      case 'ArrowRight':\n        {\n          // prevent scrolling containers\n          e.preventDefault();\n\n          var _key = state.selectedKey != null ? delegate.getKeyBelow(state.selectedKey) : delegate.getFirstKey();\n\n          if (_key) state.setSelectedKey(_key);\n          break;\n        }\n    }\n  };\n\n  var _$thkiX$useTypeSelect = $thkiX$useTypeSelect({\n    keyboardDelegate: delegate,\n    selectionManager: state.selectionManager,\n    onTypeSelect: function onTypeSelect(key) {\n      state.setSelectedKey(key);\n    }\n  }),\n      typeSelectProps = _$thkiX$useTypeSelect.typeSelectProps;\n\n  var _$thkiX$useField = $thkiX$useField(_objectSpread({}, props, {\n    labelElementType: 'span'\n  })),\n      labelProps = _$thkiX$useField.labelProps,\n      fieldProps = _$thkiX$useField.fieldProps,\n      descriptionProps = _$thkiX$useField.descriptionProps,\n      errorMessageProps = _$thkiX$useField.errorMessageProps;\n\n  typeSelectProps.onKeyDown = typeSelectProps.onKeyDownCapture;\n  delete typeSelectProps.onKeyDownCapture;\n  var domProps = $thkiX$filterDOMProps(props, {\n    labelable: true\n  });\n  var triggerProps = $thkiX$mergeProps(typeSelectProps, menuTriggerProps, fieldProps);\n  var valueId = $thkiX$useId();\n  return {\n    labelProps: _objectSpread({}, labelProps, {\n      onClick: function onClick() {\n        if (!props.isDisabled) {\n          ref.current.focus(); // Show the focus ring so the user knows where focus went\n\n          $thkiX$setInteractionModality('keyboard');\n        }\n      }\n    }),\n    triggerProps: $thkiX$mergeProps(domProps, _objectSpread({}, triggerProps, {\n      isDisabled: isDisabled,\n      onKeyDown: $thkiX$chain(triggerProps.onKeyDown, onKeyDown, props.onKeyDown),\n      onKeyUp: props.onKeyUp,\n      'aria-labelledby': [triggerProps['aria-labelledby'], triggerProps['aria-label'] && !triggerProps['aria-labelledby'] ? triggerProps.id : null, valueId].filter(Boolean).join(' '),\n      onFocus: function onFocus(e) {\n        if (state.isFocused) return;\n        if (props.onFocus) props.onFocus(e);\n        if (props.onFocusChange) props.onFocusChange(true);\n        state.setFocused(true);\n      },\n      onBlur: function onBlur(e) {\n        if (state.isOpen) return;\n        if (props.onBlur) props.onBlur(e);\n        if (props.onFocusChange) props.onFocusChange(false);\n        state.setFocused(false);\n      }\n    })),\n    valueProps: {\n      id: valueId\n    },\n    menuProps: _objectSpread({}, menuProps, {\n      autoFocus: state.focusStrategy || true,\n      shouldSelectOnPressUp: true,\n      shouldFocusOnHover: true,\n      disallowEmptySelection: true,\n      onBlur: function onBlur(e) {\n        if (e.currentTarget.contains(e.relatedTarget)) return;\n        if (props.onBlur) props.onBlur(e);\n        if (props.onFocusChange) props.onFocusChange(false);\n        state.setFocused(false);\n      },\n      'aria-labelledby': [fieldProps['aria-labelledby'], triggerProps['aria-label'] && !fieldProps['aria-labelledby'] ? triggerProps.id : null].filter(Boolean).join(' ')\n    }),\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps\n  };\n}\n\nfunction $bdd25dc72710631f$export$f809e80f58e251d1(props, state, triggerRef) {\n  var autoComplete = props.autoComplete,\n      name = props.name,\n      isDisabled = props.isDisabled;\n  var modality = $thkiX$useInteractionModality();\n\n  var _$thkiX$useVisuallyHi = $thkiX$useVisuallyHidden(),\n      visuallyHiddenProps = _$thkiX$useVisuallyHi.visuallyHiddenProps;\n\n  var _selectedKey; // In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.\n  // In Firefox, there must be a <label> to identify the <select> whereas other browsers\n  // seem to identify it just by surrounding text.\n  // The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a\n  // 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>\n  // non tabbable with tabIndex={-1}.\n  //\n  // In mobile browsers, there are next/previous buttons above the software keyboard for navigating\n  // between fields in a form. These only support native form inputs that are tabbable. In order to\n  // support those, an additional hidden input is used to marshall focus to the button. It is tabbable\n  // except when the button is focused, so that shift tab works properly to go to the actual previous\n  // input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes\n  // the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to\n  // prevent Safari from zooming in on the input when it is focused.\n  //\n  // If the current interaction modality is null, then the user hasn't interacted with the page yet.\n  // In this case, we set the tabIndex to -1 on the input element so that automated accessibility\n  // checkers don't throw false-positives about focusable elements inside an aria-hidden parent.\n\n\n  return {\n    containerProps: _objectSpread({}, visuallyHiddenProps, {\n      'aria-hidden': true\n    }),\n    inputProps: {\n      type: 'text',\n      tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,\n      style: {\n        fontSize: 16\n      },\n      onFocus: function onFocus() {\n        return triggerRef.current.focus();\n      },\n      disabled: isDisabled\n    },\n    selectProps: {\n      tabIndex: -1,\n      autoComplete: autoComplete,\n      disabled: isDisabled,\n      name: name,\n      size: state.collection.size,\n      value: (_selectedKey = state.selectedKey) !== null && _selectedKey !== void 0 ? _selectedKey : '',\n      onChange: function onChange(e) {\n        return state.setSelectedKey(e.target.value);\n      }\n    }\n  };\n}\n\nfunction $bdd25dc72710631f$export$cbd84cdb2e668835(props) {\n  var state = props.state,\n      triggerRef = props.triggerRef,\n      label = props.label,\n      name = props.name,\n      isDisabled = props.isDisabled;\n\n  var _$bdd25dc72710631f$ex = $bdd25dc72710631f$export$f809e80f58e251d1(props, state, triggerRef),\n      containerProps = _$bdd25dc72710631f$ex.containerProps,\n      inputProps = _$bdd25dc72710631f$ex.inputProps,\n      selectProps = _$bdd25dc72710631f$ex.selectProps; // If used in a <form>, use a hidden input so the value can be submitted to a server.\n  // If the collection isn't too big, use a hidden <select> element for this so that browser\n  // autofill will work. Otherwise, use an <input type=\"hidden\">.\n\n\n  if (state.collection.size <= 300) return /*#__PURE__*/$thkiX$react.createElement(\"div\", containerProps, /*#__PURE__*/$thkiX$react.createElement(\"input\", inputProps), /*#__PURE__*/$thkiX$react.createElement(\"label\", null, label, /*#__PURE__*/$thkiX$react.createElement(\"select\", selectProps, /*#__PURE__*/$thkiX$react.createElement(\"option\", null), _toConsumableArray(state.collection.getKeys()).map(function (key) {\n    var item = state.collection.getItem(key);\n    if (item.type === 'item') return /*#__PURE__*/$thkiX$react.createElement(\"option\", {\n      key: item.key,\n      value: item.key\n    }, item.textValue);\n  }))));else if (name) return /*#__PURE__*/$thkiX$react.createElement(\"input\", {\n    type: \"hidden\",\n    autoComplete: selectProps.autoComplete,\n    name: name,\n    disabled: isDisabled,\n    value: state.selectedKey\n  });\n  return null;\n}\n\nexport { $58aed456727eb0f3$export$e64b2f635402ca43 as useSelect, $bdd25dc72710631f$export$f809e80f58e251d1 as useHiddenSelect, $bdd25dc72710631f$export$cbd84cdb2e668835 as HiddenSelect };","map":null,"metadata":{},"sourceType":"module"}